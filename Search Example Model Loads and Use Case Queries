//Starting with an empty Neo4j graph instance
MATCH (a) DETACH DELETE a;

//CREATE EXAMPLE SYSTEM MODEL A
MERGE (a:Asset {name:'accumulator'})
MERGE (ee:Asset {name:'electrical energy'})-[:PRODUCED_BY {GBDR_level:"SMDL"}]->(a)
MERGE (w:Asset {name:'wire'})-[:CONNECTED_TO {GBDR_level:"SMDL"}]->(a)
MERGE (ee)-[:TRANSFERRED_BY {GBDR_level:"SMDL"}]->(w)
MERGE (m:Asset {name:'motor',maximumRPM:22500})<-[:CONNECTED_TO {GBDR_level:"SMDL"}]-(w)
MERGE (ee)-[:CONSUMED_BY {GBDR_level:"SMDL"}]->(m)
MERGE (h:Asset {name:'heat'})-[:PRODUCED_BY {GBDR_level:"SMDL"}]->(m)
MERGE (t:Asset {name:'torque'})-[:PRODUCED_BY {GBDR_level:"SMDL"}]->(m)
MERGE (d:Asset {name:'differential'})<-[:TRANSFORMED_BY {GBDR_level:"SMDL"}]->(t)
MERGE (r:Asset {name:'rotor'})<-[:CONSUMED_BY {GBDR_level:"SMDL"}]-(t)
MERGE (m)-[:CONNECTED_TO {GBDR_level:"SMDL"}]->(d)
MERGE (d)-[:CONNECTED_TO {GBDR_level:"SMDL"}]->(r)
MERGE (lift:Asset {name:'lift'})-[:PRODUCED_BY {GBDR_level:"SMDL"}]->(r);
MERGE (SMA:System_Model {name:'systemA'})
WITH SMA
MATCH (assets:Asset) SET assets:systemA SET assets:SMDL
MERGE (assets)-[:IS_CHILD_OF]->(SMA);

//CREATE EXAMPLE SYSTEM MODEL B
MERGE (a:Block {name:'battery'})
MERGE (ee:Block {name:'electrical energy'})-[:PRODUCED_BY {GBDR_level:"SMDL"}]->(a)
MERGE (w:Block {name:'wire'})-[:CONNECTED_TO {GBDR_level:"SMDL"}]->(a)
MERGE (ee)-[:TRANSFERRED_BY {GBDR_level:"SMDL"}]->(w)
MERGE (f:Block {name:'filament'})<-[:CONNECTED_TO {GBDR_level:"SMDL"}]-(w)
MERGE (ee)-[:CONSUMED_BY {GBDR_level:"SMDL"}]->(f)
MERGE (l:Block {name:'light'})-[:PRODUCED_BY {GBDR_level:"SMDL"}]->(f)
MERGE (h:Block {name:'heat'})-[:PRODUCED_BY {GBDR_level:"SMDL"}]->(f);
MERGE (SMB:System_Model {name:'systemB'})
WITH SMB
MATCH (blocks:Block)
SET blocks:systemB SET blocks:SMDL
MERGE (blocks)-[:IS_CHILD_OF]->(SMB);

//SET EXAMPLE PROPERTIES
MATCH (a:Block {name:"battery"})
SET a.voltage = 1.5
SET a.charge = 8000
SET a.rechargeable = FALSE
SET a.shape = 'cylinder'
SET a.current_type = 'DC';

MATCH (a:Asset {name:"accumulator"})
SET a.Voltage = 11.3
SET a.charge = 1600
SET a.rechareable = TRUE
SET a.current_type = 'DC';


//CREATE EXAMPLE SYSTEM MODEL C

          //Import Algorithm for Innoslate System Model from Local Drive to Neo4j GBDR.
          //Step 0: Import and Pre-processing of XML file content.
          //Step 0.1: Import XML file from local director.
          call apoc.xml.import("file:///Users/danie/.Neo4jDesktop/neo4jDatabases/database-b2c772db-f121-42a9-92d8-915048491c98/installation-4.3.5/import/Low_Fidelity_Car_Model.xml",{filterLeadingWhitespace:true,delimiter:"X0Y9A8B7"}) yield node
          return "done";

          //Step 0.2: Remove relationships generated by APOC XML Import procedure that aren't used in the GBDR.
          MATCH (a)-[n]->(b) WHERE (a:XmlDocument OR a:XmlCharacters OR a:XmlTag) AND type(n) <> 'IS_CHILD_OF' DELETE n;

          //Step 0.3: Transform uniqueProjectId and children nodes from separate nodes to labeled properties.
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT model_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH model_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(model_node,prop_name,prop_text2) YIELD node
          RETURN node;
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 0.4: Create additional labels for immediate children nodes of root content node (where name is 'innoslate').
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*1..2]-(child_node)
          WITH child_node, collect(child_node._name) AS node_name
          CALL apoc.create.addLabels(child_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 0.5: (Document level subgraph cleanup) Remove 'XmlTag' label and add 'Model_Package' label.
          MATCH(a:XmlTag {_name:"innoslate"})
          SET a:Model_Package
          REMOVE a:XmlTag;

          //Step 1.0: Generate ODL subgraph from 'schema' sub-graph.

          //Step 1.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(child_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT child_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH child_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(child_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'ODL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 1.2: Change node labels from 'XmlTag' to 'SchemaClass' and 'SchemaRelation'.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(end_node:XmlTag)
          WITH end_node, collect(end_node._name) AS node_name
          CALL apoc.create.addLabels(end_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 1.3: Create edges between connected schemaClass nodes using Id references.
          MATCH (schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF]-(rels:xmlTargetRelation)
          MATCH (a:schemaClass) WHERE a.id = rels.sourceId
          OPTIONAL MATCH (b:schemaClass) WHERE b.id = rels.targetId
          OPTIONAL MATCH (c:schemaRelation) WHERE c.id = rels.relationId
          CREATE(a)-[:source_of {GBDR_level:"ODL"}]->(c)
          CREATE(b)-[:target_of {GBDR_level:"ODL"}]->(c)
          DETACH DELETE rels;

          //Step 1.4: ODL subgraph cleanup ('schema' subgraph of XML import graph).

          //Step 1.4.1: Change label of node named 'schema' from 'XmlTag' to 'Ontology'.
          MATCH (schema:XmlTag {_name:"schema"})
          SET schema:Ontology
          REMOVE schema:XmlTag;

          //Step 1.4.2: Change relationship between schemaProperty nodes and schemaClass nodes to 'defined_by'.
          MATCH (a:schemaProperty)-[r:IS_CHILD_OF]->(b) WHERE b:schemaClass OR b:schemaRelation
          CREATE (a)<-[:defined_by {GBDR_level:"ODL"}]-(b)
          WITH r DELETE r;

          //Step 1.4.3: Create subclass relationship between parent and child classes.
          MATCH (child:schemaClass)
          MATCH (parent:schemaClass {id:child.parentId})
          CREATE (child)-[:subclass_of {GBDR_level:"ODL"}]->(parent);

          //Step 1.4.4: Create inverse relationship schemaRelations to reflect inverseRelationId.
          MATCH(r1:schemaRelation)
          MATCH(r2:schemaRelation {id:r1.inverseRelationId})
          CREATE (r1)-[:Inverse_of]->(r2);

          //Step 2.0: Generate SMDL subgraph from 'database' sub-graph of XML import graph.

          //Step 2.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 2.2: Change entity node labels from 'XmlTag' to value of 'name' property of referenced schemaClass node.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent {_name:'entity'})
          MATCH(sClass:schemaClass {id:ent.schemaClassId})
          WITH ent, collect(sClass.name) AS node_name
          CALL apoc.create.addLabels(ent,node_name) YIELD node
          SET ent:entity
          REMOVE ent:XmlTag;

          //Step 2.3: Transform relationships from nodes to edges.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(rels {_name:'relationship'})
          MATCH(target:entity {globalId:rels.targetId})
          MATCH(source:entity {globalId:rels.sourceId})
          MATCH(sRel:schemaRelation {id:rels.schemaRelationId})
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF]-(rels_link:XmlTag {_name:"booleanAttribute"})
          OPTIONAL MATCH (sProp:schemaProperty {id:rels_link.schemaPropertyId})
          WITH DISTINCT rels, rels_link, source, sRel.name as rel_name, target, sProp.name as prop_name, rels_link.booleanValue as prop_value
          CALL apoc.create.relationship(source,rel_name,{GBDR_level:"SMDL"},target) YIELD rel as rel1
          WITH rels, rels_link, rel1, prop_name, prop_value
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF*]-(rels_props)
          DETACH DELETE rels_props, rels
          WITH rel1, rels_link, prop_name, prop_value WHERE prop_name IS NOT NULL
          CALL apoc.create.setRelProperty(rel1,prop_name,prop_value) YIELD rel AS rel2
          DETACH DELETE rels_link;

          //Step 2.4: SMDL subgraph cleanup ('database' subgraph of XML import graph).

          //Step 2.4.1: Change distribution attribute children node labels from 'XmlTag' to 'distribution'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'distribution'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DISTRIBUTION
          SET nestedprops:DISTRIBUTION
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'

          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.2: Change simulation data attribute children node labels from 'XmlTag' to 'SIMDATA'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'simulationData'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:SIMDATA
          SET nestedprops:SIMDATA
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.3: Change diagram metadata node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'metadata'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.4: Change diagram node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'xmlDiagram'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.5: Change complex attribute node labels 'XmlTags' nodes to 'NestedProperty'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag) WHERE m1prop._name IN ["dateAttribute", "doubleAttribute", "durationAttribute", "stringAttribute", "numberAttribute", "qualityAttribute"
          ]
          MATCH (sProp:schemaProperty {id:m1prop.schemaPropertyId})
          SET m1prop:Nested_Property
          SET m1prop.property_name = sProp.name
          REMOVE m1prop:XmlTag;
          MATCH (nestedProps:Nested_Property)-[:IS_CHILD_OF]->(parentNode)
          SET nestedProps.GBDR_value = coalesce(nestedProps.value,nestedProps.doubleValue,nestedProps.booleanValue)
          WITH parentNode, nestedProps
          CALL apoc.create.setProperty(parentNode, nestedProps.property_name,nestedProps.GBDR_value ) YIELD node
          RETURN "done";


          //Step 2.4.6: Transform blank attribute nodes into labeled properties on parent node with value 'NULL_AT_IMPORT'.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH DISTINCT parent_node, m1prop._name as prop_name, collect("NULL_AT_IMPORT") AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH m1prop
          DETACH DELETE m1prop;

          //Step 2.4.7: Remove 'entity' labels from nodes in the the 'System_Model' subgraph.
          MATCH(:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent:entity)
          REMOVE ent:entity;

          //Step 2.4.8: Change label of node named 'database' from 'XmlTag' to 'System_Model'.
          MATCH (database:XmlTag {_name:"database"})
          SET database:System_Model
          REMOVE database:XmlTag;

          //Step 2.4.9: Change label of 'xmlDocument' node to  'importedXmlDocument'.
          MATCH (a:XmlDocument)
          SET a:importedXmlDocument
          REMOVE a:XmlDocument;

          //Step 3.0: Condense Label subgraph into Reference Form (not used in initial GBDR instantiation).

          //Step 3.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 3.2: Create edge between parent and child label nodes.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(child) WHERE child.parentId is not null
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent {id:child.parentId})
          CREATE (child)-[:child_of]->(parent);

          //Step 3.3: Create an edge between label nodes and the schema class to which they point.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(label) WHERE label.schemaClassId is not null
          MATCH(sClass:schemaClass {id:label.schemaClassId})
          CREATE (label)-[:label_for]->(sClass);

          //Step 3.4: (Label subgraph cleanup) Remove 'XmlTag' label and add 'Innoslate_Label' as node label.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*0..]-(lab)
          SET lab:Innoslate_Labels
          REMOVE lab:XmlTag;




//Add systemC labels
MATCH (a)-[:IS_CHILD_OF*1..]->(b:System_Model)-[:IS_CHILD_OF]->(c:Model_Package{uniqueProjectId:'-1578017800'})
SET a:systemC
WITH DISTINCT b
SET b.name='systemC';


//CREATE EXAMPLE SYSTEM MODEL D


          //Import Algorithm for Innoslate System Model from Local Drive to Neo4j GBDR.
          //Step 0: Import and Pre-processing of XML file content.
          //Step 0.1: Import XML file from local director.
          call apoc.xml.import("file:///Users/danie/.Neo4jDesktop/neo4jDatabases/database-b2c772db-f121-42a9-92d8-915048491c98/installation-4.3.5/import/High_Fidelity_RC_Car_Model.xml",{filterLeadingWhitespace:true,delimiter:"X0Y9A8B7"}) yield node
          return "done";

          //Step 0.2: Remove relationships generated by APOC XML Import procedure that aren't used in the GBDR.
          MATCH (a)-[n]->(b) WHERE (a:XmlDocument OR a:XmlCharacters OR a:XmlTag) AND type(n) <> 'IS_CHILD_OF' DELETE n;

          //Step 0.3: Transform uniqueProjectId and children nodes from separate nodes to labeled properties.
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT model_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH model_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(model_node,prop_name,prop_text2) YIELD node
          RETURN node;
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 0.4: Create additional labels for immediate children nodes of root content node (where name is 'innoslate').
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*1..2]-(child_node)
          WITH child_node, collect(child_node._name) AS node_name
          CALL apoc.create.addLabels(child_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 0.5: (Document level subgraph cleanup) Remove 'XmlTag' label and add 'Model_Package' label.
          MATCH(a:XmlTag {_name:"innoslate"})
          SET a:Model_Package
          REMOVE a:XmlTag;

          //Step 1.0: Generate ODL subgraph from 'schema' sub-graph.

          //Step 1.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(child_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT child_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH child_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(child_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'ODL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 1.2: Change node labels from 'XmlTag' to 'SchemaClass' and 'SchemaRelation'.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(end_node:XmlTag)
          WITH end_node, collect(end_node._name) AS node_name
          CALL apoc.create.addLabels(end_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 1.3: Create edges between connected schemaClass nodes using Id references.
          MATCH (schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF]-(rels:xmlTargetRelation)
          MATCH (a:schemaClass) WHERE a.id = rels.sourceId
          OPTIONAL MATCH (b:schemaClass) WHERE b.id = rels.targetId
          OPTIONAL MATCH (c:schemaRelation) WHERE c.id = rels.relationId
          CREATE(a)-[:source_of {GBDR_level:"ODL"}]->(c)
          CREATE(b)-[:target_of {GBDR_level:"ODL"}]->(c)
          DETACH DELETE rels;

          //Step 1.4: ODL subgraph cleanup ('schema' subgraph of XML import graph).

          //Step 1.4.1: Change label of node named 'schema' from 'XmlTag' to 'Ontology'.
          MATCH (schema:XmlTag {_name:"schema"})
          SET schema:Ontology
          REMOVE schema:XmlTag;

          //Step 1.4.2: Change relationship between schemaProperty nodes and schemaClass nodes to 'defined_by'.
          MATCH (a:schemaProperty)-[r:IS_CHILD_OF]->(b) WHERE b:schemaClass OR b:schemaRelation
          CREATE (a)<-[:defined_by {GBDR_level:"ODL"}]-(b)
          WITH r DELETE r;

          //Step 1.4.3: Create subclass relationship between parent and child classes.
          MATCH (child:schemaClass)
          MATCH (parent:schemaClass {id:child.parentId})
          CREATE (child)-[:subclass_of {GBDR_level:"ODL"}]->(parent);

          //Step 1.4.4: Create inverse relationship schemaRelations to reflect inverseRelationId.
          MATCH(r1:schemaRelation)
          MATCH(r2:schemaRelation {id:r1.inverseRelationId})
          CREATE (r1)-[:Inverse_of]->(r2);

          //Step 2.0: Generate SMDL subgraph from 'database' sub-graph of XML import graph.

          //Step 2.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 2.2: Change entity node labels from 'XmlTag' to value of 'name' property of referenced schemaClass node.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent {_name:'entity'})
          MATCH(sClass:schemaClass {id:ent.schemaClassId})
          WITH ent, collect(sClass.name) AS node_name
          CALL apoc.create.addLabels(ent,node_name) YIELD node
          SET ent:entity
          REMOVE ent:XmlTag;

          //Step 2.3: Transform relationships from nodes to edges.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(rels {_name:'relationship'})
          MATCH(target:entity {globalId:rels.targetId})
          MATCH(source:entity {globalId:rels.sourceId})
          MATCH(sRel:schemaRelation {id:rels.schemaRelationId})
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF]-(rels_link:XmlTag {_name:"booleanAttribute"})
          OPTIONAL MATCH (sProp:schemaProperty {id:rels_link.schemaPropertyId})
          WITH DISTINCT rels, rels_link, source, sRel.name as rel_name, target, sProp.name as prop_name, rels_link.booleanValue as prop_value
          CALL apoc.create.relationship(source,rel_name,{GBDR_level:"SMDL"},target) YIELD rel as rel1
          WITH rels, rels_link, rel1, prop_name, prop_value
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF*]-(rels_props)
          DETACH DELETE rels_props, rels
          WITH rel1, rels_link, prop_name, prop_value WHERE prop_name IS NOT NULL
          CALL apoc.create.setRelProperty(rel1,prop_name,prop_value) YIELD rel AS rel2
          DETACH DELETE rels_link;

          //Step 2.4: SMDL subgraph cleanup ('database' subgraph of XML import graph).

          //Step 2.4.1: Change distribution attribute children node labels from 'XmlTag' to 'distribution'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'distribution'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DISTRIBUTION
          SET nestedprops:DISTRIBUTION
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'

          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.2: Change simulation data attribute children node labels from 'XmlTag' to 'SIMDATA'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'simulationData'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:SIMDATA
          SET nestedprops:SIMDATA
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.3: Change diagram metadata node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'metadata'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.4: Change diagram node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'xmlDiagram'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.5: Change complex attribute node labels 'XmlTags' nodes to 'NestedProperty'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag) WHERE m1prop._name IN ["dateAttribute", "doubleAttribute", "durationAttribute", "stringAttribute", "numberAttribute", "qualityAttribute"
          ]
          MATCH (sProp:schemaProperty {id:m1prop.schemaPropertyId})
          SET m1prop:Nested_Property
          SET m1prop.property_name = sProp.name
          REMOVE m1prop:XmlTag;

          MATCH (nestedProps:Nested_Property)-[:IS_CHILD_OF]->(parentNode)
          SET nestedProps.GBDR_value = coalesce(nestedProps.value,nestedProps.doubleValue,nestedProps.booleanValue)
          WITH parentNode, nestedProps
          CALL apoc.create.setProperty(parentNode, nestedProps.property_name,nestedProps.GBDR_value ) YIELD node
          RETURN "done";

          //Step 2.4.6: Transform blank attribute nodes into labeled properties on parent node with value 'NULL_AT_IMPORT'.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH DISTINCT parent_node, m1prop._name as prop_name, collect("NULL_AT_IMPORT") AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH m1prop
          DETACH DELETE m1prop;

          //Step 2.4.7: Remove 'entity' labels from nodes in the the 'System_Model' subgraph.
          MATCH(:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent:entity)
          REMOVE ent:entity;

          //Step 2.4.8: Change label of node named 'database' from 'XmlTag' to 'System_Model'.
          MATCH (database:XmlTag {_name:"database"})
          SET database:System_Model
          REMOVE database:XmlTag;

          //Step 2.4.9: Change label of 'xmlDocument' node to  'importedXmlDocument'.
          MATCH (a:XmlDocument)
          SET a:importedXmlDocument
          REMOVE a:XmlDocument;

          //Step 3.0: Condense Label subgraph into Reference Form (not used in initial GBDR instantiation).

          //Step 3.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 3.2: Create edge between parent and child label nodes.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(child) WHERE child.parentId is not null
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent {id:child.parentId})
          CREATE (child)-[:child_of]->(parent);

          //Step 3.3: Create an edge between label nodes and the schema class to which they point.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(label) WHERE label.schemaClassId is not null
          MATCH(sClass:schemaClass {id:label.schemaClassId})
          CREATE (label)-[:label_for]->(sClass);

          //Step 3.4: (Label subgraph cleanup) Remove 'XmlTag' label and add 'Innoslate_Label' as node label.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*0..]-(lab)
          SET lab:Innoslate_Labels
          REMOVE lab:XmlTag;


//Add systemD labels
MATCH (a)-[:IS_CHILD_OF*1..]->(b:System_Model)-[:IS_CHILD_OF]->(c:Model_Package{uniqueProjectId:'-118053432'})
SET a:systemD
WITH DISTINCT b
SET b.name='systemD';

//Set SMDL node label for all elements in system_model retrieves
MATCH (a)-[:IS_CHILD_OF*1..]->(b:System_Model)
WITH DISTINCT a
SET a:SMDL;

















//Perform Synthesis Steps for All Nodes with a "name" property_name


          //Code below creates syntheticElements that match the name of each node with the name property key
          //For application to other node labels, only the first match operation needs to be changed
          MATCH (smdl_nodes)
          WHERE 'name' IN keys(smdl_nodes)
          AND(('systemA' IN labels(smdl_nodes)) OR ('systemB' IN labels(smdl_nodes)) OR ('systemC' IN labels(smdl_nodes))
          OR ('systemD' IN labels(smdl_nodes)))
          //Section below retrieves matching wikidata items based on rdfs:label
          //Returned items are added to the GBDR as a syntheticElement node (root synthetic node)
          //A relationship between the created between syntheticElement node and SMDL node
          WITH "SELECT ?subject ?subjectName ?subjectDescription WHERE { ?subject rdfs:label \"" +
          toLower(smdl_nodes.name) + "\"@en . ?subject schema:description ?subjectDescription filter(lang(?subjectDescription) = \"en\"). ?subject rdfs:label ?subjectName filter(lang(?subjectName) = \"en\").}" AS sparql, smdl_nodes
          CALL apoc.load.jsonParams(
            "http://query.wikidata.org/sparql?query=" + sparql,
            { Accept: "application/sparql-results+json",failOnError:false},
            null) YIELD value
          WITH value, smdl_nodes
          CALL apoc.do.when(
            size(value.results.bindings) > 0,
            '
            UNWIND value.results.bindings AS result
            WITH result, smdl_nodes
             MERGE (synEle:syntheticElement {name:result.subjectName.value, globalId:result.subject.value, description:result.subjectDescription.value})
             MERGE (smdl_nodes)-[:SYNTHETIC_DEFINED_BY {Synthetic:"TRUE"}]->(synEle)
             RETURN smdl_nodes',
             'SET smdl_nodes.SYNTH_DATA_IMPORT = true RETURN smdl_nodes',
            {value: value, smdl_nodes: smdl_nodes})
          YIELD value AS result
          WITH smdl_nodes
          //Query wikidata for the value of "said to be the same as" (P460) for root synthetic node
          MATCH (smdl_nodes)-[:SYNTHETIC_DEFINED_BY]->(synthEle)
          WITH DISTINCT synthEle as synthSet
          WITH "SELECT ?sameAsId ?sameAsName ?sameAsDescription WHERE { <" +
          synthSet.globalId + "> wdt:P460 ?sameAsId . ?sameAsId schema:description ?sameAsDescription filter(lang(?sameAsDescription) = \"en\").  ?sameAsId rdfs:label ?sameAsName filter(lang(?sameAsName) = \"en\").}" AS sparql, synthSet
          CALL apoc.load.jsonParams(
            "http://query.wikidata.org/sparql?query=" + sparql,
            { Accept: "application/sparql-results+json",failOnError:false},
            null)
          YIELD value
          CALL apoc.do.when(
            size(value.results.bindings) > 0,
            '
            UNWIND value.results.bindings AS result
            WITH result, synthSet
            MERGE (synEle:syntheticElement {name:result.sameAsName.value, globalId:result.sameAsId.value, description:result.sameAsDescription.value})
            MERGE (synthSet)-[:SYNTHETIC_SAME_AS {Synthetic:"TRUE"}]-(synEle)
            RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
            {value: value, synthSet : synthSet})
          YIELD value AS result

          //Query wikidata for the value of "synonym" (P5973) for root synthetic node
          WITH synthSet
          WITH "SELECT ?synonymOfId ?synonymOfName ?synonymOfDescription WHERE { <" +
          synthSet.globalId + "> wdt:P5973 ?synonymOfId . ?synonymOfId schema:description ?synonymOfDescription filter(lang(?synonymOfDescription) = \"en\").  ?synonymOfId rdfs:label ?synonymOfName filter(lang(?synonymOfName) = \"en\").}" AS sparql, synthSet
          CALL apoc.load.jsonParams(
            "http://query.wikidata.org/sparql?query=" + sparql,
            { Accept: "application/sparql-results+json",failOnError:false},
            null)
          YIELD value
          CALL apoc.do.when(
            size(value.results.bindings) > 0,
            '
            UNWIND value.results.bindings AS result
            WITH result, synthSet WHERE result is not null
            MERGE (synEle:syntheticElement {name:result.synonymOfName.value, globalId:result.synonymOfId.value, description:result.synonymOfDescription.value})
            MERGE (synthSet)-[:SYNTHETIC_SYNONYM_OF {Synthetic:"TRUE"}]-(synEle)
            RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
            {value: value, synthSet : synthSet})
          YIELD value AS result

          //Query wikidata for the value of "instance of" (P31) for root synthetic node
          WITH synthSet
          WITH "SELECT ?instanceOfId ?instanceOfName ?instanceOfDescription WHERE { <" +
          synthSet.globalId + "> wdt:P31 ?instanceOfId . ?instanceOfId schema:description ?instanceOfDescription filter(lang(?instanceOfDescription) = \"en\").  ?instanceOfId rdfs:label ?instanceOfName filter(lang(?instanceOfName) = \"en\").}" AS sparql, synthSet
          CALL apoc.load.jsonParams(
            "http://query.wikidata.org/sparql?query=" + sparql,
            { Accept: "application/sparql-results+json",failOnError:false},
            null)
          YIELD value
          CALL apoc.do.when(
            size(value.results.bindings) > 0,
            '
            UNWIND value.results.bindings AS result
            WITH result, synthSet WHERE result is not null
            MERGE (synEle:syntheticElement {name:result.instanceOfName.value, globalId:result.instanceOfId.value, description:result.instanceOfDescription.value})
            MERGE (synthSet)-[:SYNTHETIC_INSTANCE_OF {Synthetic:"TRUE"}]-(synEle)
            RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
            {value: value, synthSet : synthSet})
          YIELD value AS result

          //Query wikidata for the value of "exact match" (P2888) for root synthetic node
          WITH synthSet
          WITH "SELECT ?exactMatchId ?exactMatchName ?exactMatchDescription WHERE { <" +
          synthSet.globalId + "> wdt:P31 ?exactMatchId . ?exactMatchId schema:description ?exactMatchDescription filter(lang(?exactMatchDescription) = \"en\").  ?exactMatchId rdfs:label ?exactMatchName filter(lang(?exactMatchName) = \"en\").}" AS sparql, synthSet
          CALL apoc.load.jsonParams(
            "http://query.wikidata.org/sparql?query=" + sparql,
            {Accept: "application/sparql-results+json",failOnError:false},
            null)
          YIELD value
          CALL apoc.do.when(
            size(value.results.bindings) > 0,
            '
            UNWIND value.results.bindings AS result
            WITH result, synthSet WHERE result is not null
            MERGE (synEle:syntheticElement {name:result.exactMatchName.value, globalId:result.exactMatchId.value, description:result.exactMatchDescription.value})
            MERGE (synthSet)-[:SYNTHETIC_EXACT_MATCH {Synthetic:"TRUE"}]-(synEle)
            RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
            {value: value, synthSet : synthSet})
          YIELD value AS result

          //Query wikidata for the superclass of all existing syntheticElements connected
          //to the root synthetic node
          MATCH (smdl_nodes)-[:SYNTHETIC_DEFINED_BY ]->()-[*0..1]->(synthEle)
          WITH DISTINCT synthEle as synthSet
          WITH "SELECT ?superClassId ?superClassName ?superClassDescription WHERE { <" +
          synthSet.globalId + "> wdt:P279 ?superClassId . ?superClassId schema:description ?superClassDescription filter(lang(?superClassDescription) = \"en\").  ?superClassId rdfs:label ?superClassName filter(lang(?superClassName) = \"en\").}" AS sparql, synthSet
          CALL apoc.load.jsonParams(
            "http://query.wikidata.org/sparql?query=" + sparql,
            { Accept: "application/sparql-results+json", failOnError:false},
            null)
          YIELD value

          CALL apoc.do.when(
            size(value.results.bindings) > 0,
            '
            UNWIND value.results.bindings AS result
            WITH result, synthSet WHERE result is not null
            MERGE (synEle:syntheticElement {name:result.superClassName.value, globalId:result.superClassId.value, description:result.superClassDescription.value})
            MERGE (synthSet)-[:SYNTHETIC_SUBCLASS_OF {Synthetic:"TRUE"}]-(synEle)
            RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
            {value: value, synthSet : synthSet})
          YIELD value AS result
          RETURN "done";

//Identify Potentially Equivalent Nodes
MATCH p=(smA:System_Model)<-[:IS_CHILD_OF*1..]-(a)-[*0..5{Synthetic:'TRUE'}]-(b)-[:IS_CHILD_OF*1..]->(smB:System_Model)
WHERE smA<>smB
AND NOT a:syntheticElement
AND NOT b:syntheticElement
AND id(a)>id(b) //Avoids two pairs of (a,b) and (b,a)
WITH DISTINCT a,b
MERGE (a)-[:POTENTIAL_MATCH]-(b);

//Node Similarity Algorithm

//Calculate node similarity score as Jaccardian similarity of property keys
//Retrieve all pairs of potentially matched nodes
MATCH (nodeA)-[r:POTENTIAL_MATCH]->(nodeB)
//Determine cardinality of property key intersection
CALL{
    WITH nodeA,nodeB
    WITH nodeA as a, nodeB as b
    WITH keys(a) AS a_prop_keys, keys(b) AS b_prop_keys
    UNWIND a_prop_keys as a_list
    UNWIND b_prop_keys as b_list
    //Strip everything except alphanumeric characters and convert to lower case.
    WITH apoc.text.clean(a_list) as clean_a, apoc.text.clean(b_list) as clean_b
    //Determine if pairs are fuzzy match and calculate edit distance
    WITH clean_a, clean_b, apoc.text.fuzzyMatch(clean_a,clean_b) as fuzzyMatch, apoc.text.levenshteinDistance(clean_a,clean_b) AS pair_lev_dist
    //Count as intersect if a fuzzy match or edit distance < 2
    WITH DISTINCT clean_a, (fuzzyMatch=true OR pair_lev_dist<2) AS prop_match WHERE prop_match=TRUE
    RETURN count(prop_match) AS intersectCount }

//Determine cardinality of the union of properties
WITH r,intersectCount, (size(keys(nodeA)) + size(keys(nodeB)) - intersectCount) as unionCount
//Calculate Jaccardian similarity and set POSSIBLE_MATCH rel property accordingly
//Intersect and union counts reduced by one to account for .name property
//Using *10^3 in numerator and denominator changes the default calculation from integer to float
WITH r, ((intersectCount-1)*10^3)/((unionCount-1)*10^3) AS jaccardSimilarity
SET r.nodeSimilarity = jaccardSimilarity;



//Calculate Context Similarity Score
MATCH (nodeA)-[r:POTENTIAL_MATCH]->(nodeB)
//Get combined count of neighbors.  Last number in relationship length determines neighborhood radius
CALL{
    WITH nodeA, nodeB
    WITH nodeA as a, nodeB as b
    OPTIONAL MATCH (a)-[*1..2{GBDR_level:"SMDL"}]-(aNeighbors)
    WITH (b),count(DISTINCT aNeighbors) AS aNeighbors
    OPTIONAL MATCH (b)-[*1..2{GBDR_level:"SMDL"}]-(bNeighbors)
    WITH aNeighbors, count(DISTINCT bNeighbors) as bNeighbors
    RETURN (aNeighbors + bNeighbors) AS neighbor_count
}

//Get count of neighbors with a match in the other system
CALL{
    WITH nodeA, nodeB
    WITH nodeA as a, nodeB as b
    OPTIONAL MATCH (a)-[*1..2{GBDR_level:"SMDL"}]-(aNeighbors)
    OPTIONAL MATCH (b)-[*1..2{GBDR_level:"SMDL"}]-(bNeighbors)
    MATCH(aNeighbors)-[:POTENTIAL_MATCH]-(bNeighbors) WHERE aNeighbors <> a AND bNeighbors <> b
    RETURN count(DISTINCT aNeighbors) + count(DISTINCT bNeighbors) AS match_count
}

//Calculate cumulative value for binomial distribution n = neighbor count, k = match count
//p is a tuning parameter that can be used to adjust context scores to reflect consistency
//of language across all system models, and coverage of the semantic framework

CALL
{
    WITH neighbor_count, match_count
    WITH neighbor_count as n, match_count as k

    //Calculating Binomial CDF in Cypher
    MERGE (binom:GBDR_TEMP {k:k,n:n,p:.5}) //k,n,p params
    WITH binom
    SET binom.value = (1-binom.p)^(binom.n)
    SET binom.coeff_value=1
    FOREACH(i IN range(1,binom.k) |
        SET binom.coeff_value=1
        FOREACH(j IN range(1,i) |
            SET binom.coeff_value = binom.coeff_value * ((binom.n + 1 - j)/j))
        SET binom.value = binom.value + binom.coeff_value * binom.p^i * (1-binom.p)^(binom.n-i)
    )
    WITH binom, binom.value AS a
    DELETE binom
    RETURN a AS cdf_value
}
SET r.contextSimilarity = cdf_value;



//Search Use classes
//Single Node Search

//Use Case #1
MATCH (results:Asset:SMDL)
RETURN results;

//51


//Use Case #2
MATCH (results:SMDL)
WHERE 'voltage' IN keys(results)
OR 'Voltage' IN keys(results)
RETURN results;

//4 records


//Use Case #3
MATCH (results:SMDL {current_type:"DC"})
RETURN results;

//2 records

//Use Case #4
MATCH (results:SMDL)
WHERE any(key in keys(results) WHERE results[key] = 'DC')
RETURN results;

//4 results

//Use Case #5
MATCH (results:Asset:SMDL)
WHERE 'Voltage' IN keys(results)
RETURN results;

//3 results

//Use Case #6
MATCH (results:SMDL)
WHERE results.current_type = "DC"
AND results.voltage < 45
RETURN results;

//1 result
//Use Cases for Single Node Search with Context Considerations

//Use Case #7
MATCH (results:SMDL)-[:`decomposed by`]->()
RETURN results;

//58 results

//Use Case #8
MATCH (results:Asset)-[rel{Synthetic:"TRUE"}]->()
WHERE results:SMDL
RETURN results;

//78 results

//Use Case #9
MATCH (results)-[]-({name:'Electrical Energy'})
WHERE results:SMDL
RETURN results;

//104 results

//Use Case #10
MATCH (results)<-[:`consumed by`]-({name:'Electrical Energy'})
WHERE results:SMDL
RETURN results;

//10 results

//Use Cases for Defined Complex Patterns

//Use Case #11
MATCH results = (a:SMDL{name:'electrical energy'})-[]-(:SMDL)-[]-(b:SMDL{name:'motor'})
RETURN results;

//4 records

//Use Case #12
MATCH results = (a:SMDL{name:'electrical energy'})-[]-(:SMDL)-[:CONNECTED_TO]-(b:SMDL{name:'motor'})
RETURN results;

//1 record

//Use Case #13
MATCH results = (a:SMDL{name:'electrical energy'})-[]-(:SMDL)-[:CONNECTED_TO]-(b:SMDL{name:'motor'})
WHERE b.maximumRPM > 20000
RETURN results;
//1 result

//Use Case #14
MATCH results = ({name:'electrical energy'})-[]-()-[:CONNECTED_TO]-(motor{name:'motor'})<-[:PRODUCED_BY]-({name:"heat"})-[:RECEIVED_BY]->({name:"heat sink"})
WHERE ALL(n in nodes(results) WHERE n:SMDL)
AND motor.maximumRPM >= 20000
RETURN results;
//1 result

//Use Cases for System Models Including a Set of Elements
//Use Case #15
MATCH (b:SMDL)-[:IS_CHILD_OF]->(results:System_Model)<-[:IS_CHILD_OF]-(m:SMDL)
WHERE toLower(b.name) = 'battery'
AND toLower(m.name) = 'motor'
RETURN DISTINCT results;

//Use Case #16
MATCH p=((b:SMDL)-[:IS_CHILD_OF]->(results:System_Model)<-[:IS_CHILD_OF]-(m:SMDL))
WHERE toLower(b.name) = 'battery'
AND toLower(m.name) = 'motor'
AND b.charge / m.amperage > .5
RETURN results, b.charge / m.amperage > .5 AS run_time;
//1 result (system D, 2.5 hour run time)

//Use Cases for Shortest Path between Super-pattern Features
//Use Case #17
MATCH (startN:SMDL),(endN:SMDL)
WHERE startN.name IN ['Battery','battery']
AND endN.name IN ['Motor','motor']
WITH DISTINCT startN, endN
MATCH results = shortestPath((startN)-[*]-(endN))
WHERE all(r IN relationships(results) WHERE (r.GBDR_level = "SMDL"))
RETURN DISTINCT results;

//Returns 8 paths all system D (2 motors x 8 engines))

//Use Case #18
MATCH (startN:SMDL),(endN:SMDL)
WHERE startN.name IN ['Battery','battery']
AND endN.name IN ['Motor','motor']
WITH DISTINCT startN, endN
MATCH results = shortestPath((startN)-[*]-(endN))
WHERE all(r IN relationships(results) WHERE (r.GBDR_level = "SMDL" OR
    ((type(r)="POTENTIAL_MATCH") AND ((r.contextSimilarity>=.40) AND r.nodeSimilarity>=.5))))
RETURN DISTINCT results;

//9 Total results: Additional use case = system B battery -> system A motor (via match between to system A accumulator and system B battery )

//K-Expanded Shortest Paths
//Use Case #19
MATCH (startN:SMDL),(endN:SMDL)
WHERE startN.name IN ['Battery','battery']
AND endN.name IN ['Motor','motor']
WITH DISTINCT startN, endN
MATCH results = shortestPath((startN)-[*]-(endN))
WHERE all(r IN relationships(results) WHERE (r.GBDR_level = "SMDL"))
CALL
{
    WITH results
    WITH nodes(results) AS originalPath
    UNWIND originalPath AS pathNodes
    MATCH p=(pathNodes)-[*1..1]-()
    WHERE all(r IN relationships(p) WHERE (r.GBDR_level = "SMDL"))
    RETURN COLLECT(p) AS associated_Paths
}
WITH associated_Paths, COLLECT(results) as resCol
WITH associated_Paths + resCol AS results
CALL
 {
     WITH results
     UNWIND results as SMresults
     WITH nodes(SMresults) AS rNodes
     UNWIND rNodes as rNodes2
     WITH DISTINCT rNodes2 as rNodes
     RETURN COLLECT(rNodes) as rNodes
 }
 WITH rNodes, results
 CALL
 {
     WITH results
     UNWIND results as SMresults
     WITH relationships(SMresults) AS rRelationships
     UNWIND rRelationships as rRelationships2
     WITH DISTINCT rRelationships2 as rRelationships
     RETURN COLLECT(rRelationships) as rRelationships
}
WITH DISTINCT rNodes, rRelationships, size(rNodes) AS nodecount
RETURN rNodes, rRelationships;

//Use Case #20
MATCH (startN:SMDL),(endN:SMDL)
WHERE startN.name IN ['Battery','battery']
AND endN.name IN ['Motor','motor']
WITH DISTINCT startN, endN
MATCH results = shortestPath((startN)-[*]-(endN))
WHERE all(r IN relationships(results) WHERE (r.GBDR_level = "SMDL" OR
    (type(r)="POTENTIAL_MATCH") AND ((r.contextSimilarity>=.40) AND r.nodeSimilarity>=.5)))
CALL
{
    WITH results
    WITH nodes(results) AS originalPath
    UNWIND originalPath AS pathNodes
    MATCH p=(pathNodes)-[*1..1]-()
    WHERE all(r IN relationships(p) WHERE (r.GBDR_level = "SMDL"))
    RETURN COLLECT(p) AS associated_Paths
}
WITH associated_Paths, COLLECT(results) as resCol
WITH associated_Paths + resCol AS results
CALL
 {
     WITH results
     UNWIND results as SMresults
     WITH nodes(SMresults) AS rNodes
     UNWIND rNodes as rNodes2
     WITH DISTINCT rNodes2 as rNodes
     RETURN COLLECT(rNodes) as rNodes
 }
 WITH rNodes, results
 CALL
 {
     WITH results
     UNWIND results as SMresults
     WITH relationships(SMresults) AS rRelationships
     UNWIND rRelationships as rRelationships2
     WITH DISTINCT rRelationships2 as rRelationships
     RETURN COLLECT(rRelationships) as rRelationships
}
WITH DISTINCT rNodes, rRelationships, size(rNodes) AS nodecount
RETURN rNodes, rRelationships;

//Bounded Subgraph Traversal
//Use Case #21
CALL{
OPTIONAL MATCH (b:BOUNDARY)
REMOVE b.boundaryCondition
REMOVE b:BOUNDARY
RETURN "done" as temp
}
WITH "1" as temp
CALL{
OPTIONAL MATCH ()-[a:TEMP_SEARCH_REL]-()
DELETE a
RETURN "done" as temp2
}
WITH "1" as temp
WITH COLLECT(temp) AS temp
CALL {
  MATCH boundary = (insideNode:SMDL)
    WHERE insideNode.name IN ["electrical energy","Electrical Energy","battery","Battery","accumulator"]
  RETURN boundary, insideNode
}
WITH boundary, insideNode
WITH COLLECT(boundary) AS boundaryset, COLLECT(insideNode) AS insideNodes
UNWIND (boundaryset) AS boundary
UNWIND
  CASE
    WHEN relationships(boundary) = [] THEN [null]
    ELSE relationships(boundary)
  END AS bRels
UNWIND nodes(boundary) as bNodes
WITH COLLECT(bRels) as boundaryRelationships, COLLECT(bNodes) AS boundaryNodes, insideNodes
UNWIND insideNodes AS insideNode

//FOR SINGLE SYSTEM MODEL RESULTS
MATCH (insideNode)-[:IS_CHILD_OF]->(sModel:System_Model)
WITH COLLECT(insideNode) AS matchedNodes, sModel, boundaryRelationships, boundaryNodes
WITH matchedNodes, size(matchedNodes) AS matchedCount, boundaryRelationships, boundaryNodes
WITH matchedNodes, boundaryRelationships, boundaryNodes where matchedCount >= 2 //Number of boundary criteria

CALL{
  WITH matchedNodes, boundaryRelationships, boundaryNodes
  UNWIND matchedNodes AS insideNode
  WITH insideNode, boundaryRelationships, boundaryNodes
  MATCH results=shortestPath((insideNode)-[*1..]-(endNode:SMDL))
  WHERE
  insideNode <> endNode
  AND ALL(r in relationships(results)
           WHERE NOT (r IN boundaryRelationships)
           AND r.GBDR_level = "SMDL"
           AND NOT type(r) IN ["CONNECTED_BY","CONNECTED_TO"]
        )
  AND ALL(n in nodes(results)
           WHERE n:SMDL AND
            ((NOT n IN (boundaryNodes)) OR n = insideNode OR n=endNode)
         )
  return COLLECT(results) AS results}
  WITH results
  CALL{
      WITH results
      UNWIND results as SMresults
      WITH nodes(SMresults) AS rNodes
      UNWIND rNodes as rNodes2
      WITH DISTINCT rNodes2 as rNodes
      RETURN COLLECT(rNodes) as rNodes
  }
  WITH rNodes, results
  CALL{
      WITH results
      UNWIND results as SMresults
      WITH relationships(SMresults) AS rRelationships
      UNWIND rRelationships as rRelationships2
      WITH DISTINCT rRelationships2 as rRelationships
      RETURN COLLECT(rRelationships) as rRelationships
}
RETURN rNodes, rRelationships;


//Use Case #22
CALL{
OPTIONAL MATCH (b:BOUNDARY)
REMOVE b.boundaryCondition
REMOVE b:BOUNDARY
RETURN "done" as temp
}
WITH "1" as temp
CALL{
OPTIONAL MATCH ()-[a:TEMP_SEARCH_REL]-()
DELETE a
RETURN "done" as temp2
}
WITH "1" as temp
WITH COLLECT(temp) AS temp

CALL {
 MATCH boundary = (insideNode:SMDL) WHERE insideNode.name IN ["electrical energy","Electrical Energy"]
 SET insideNode.boundaryCondition = 1 SET insideNode:BOUNDARY
 RETURN boundary, insideNode
 UNION
  MATCH boundary = (insideNode:SMDL) WHERE insideNode.name IN ["battery","Battery","accumulator"]
 SET insideNode.boundaryCondition = 2 SET insideNode:BOUNDARY
 RETURN boundary, insideNode
 UNION
 MATCH boundary = (insideNode:SMDL{name:"heat"})
 SET insideNode.boundaryCondition = 3 SET insideNode:BOUNDARY
 RETURN boundary, insideNode
}
WITH boundary, insideNode
WITH COLLECT(boundary) AS boundaryset, COLLECT(insideNode) AS insideNodes
UNWIND (boundaryset) AS boundary
UNWIND
  CASE
    WHEN relationships(boundary) = [] THEN [null]
    ELSE relationships(boundary)
  END AS bRels
UNWIND nodes(boundary) as bNodes
WITH COLLECT(bRels) as boundaryRelationships, COLLECT(bNodes) AS boundaryNodes, insideNodes, insideNodes as insideNodes2
UNWIND insideNodes AS insideNode
UNWIND insideNodes2 as insideNodeCart //Cart = cartesian

MATCH results=shortestPath((insideNode)-[*1..]-(insideNodeCart))
  WHERE
  insideNode <> insideNodeCart
  AND ALL(r in relationships(results)
           WHERE NOT (r IN boundaryRelationships)
           AND (r.GBDR_level = "SMDL" OR r.nodeSimilarity >= .75)
           AND NOT type(r) IN ["CONNECTED_BY","CONNECTED_TO","connected by","connects to"]
        )
  AND ALL(n in nodes(results)
           WHERE n:SMDL)
  AND id(insideNode) > id(insideNodeCart)
CREATE (insideNode)-[:TEMP_SEARCH_REL]->(insideNodeCart)
WITH boundaryNodes, boundaryRelationships LIMIT 1

MATCH hyperboundary = (a1:BOUNDARY{boundaryCondition:1})-[:TEMP_SEARCH_REL]-(a2:BOUNDARY) WHERE a2.boundaryCondition <>1
WITH hyperboundary, nodes(hyperboundary) AS bounds1to2, boundaryNodes, boundaryRelationships
UNWIND bounds1to2 as nodes1to2
MATCH hyperboundary2 = (nodes1to2)-[:TEMP_SEARCH_REL]-(b2:BOUNDARY)
WHERE ALL(n in nodes(hyperboundary) WHERE n.boundaryCondition <> b2.boundaryCondition)
WITH DISTINCT nodes(hyperboundary) + nodes(hyperboundary2) AS bounds1to3, boundaryNodes, boundaryRelationships
UNWIND bounds1to3 AS bounds1to3uw
WITH DISTINCT bounds1to3uw, bounds1to3, boundaryNodes, boundaryRelationships ORDER BY bounds1to3uw
WITH COLLECT(bounds1to3uw) AS matchedNodes, bounds1to3, boundaryNodes, boundaryRelationships
WITH DISTINCT matchedNodes, boundaryNodes, boundaryRelationships

CALL{
 WITH matchedNodes, boundaryRelationships, boundaryNodes
 UNWIND matchedNodes AS insideNode
 WITH insideNode,matchedNodes, boundaryRelationships, boundaryNodes
 MATCH results=shortestPath((insideNode)-[*1..]-(endNode:SMDL))
 WHERE
 insideNode <> endNode
 AND ALL(r in relationships(results)
          WHERE
          NOT (r IN boundaryRelationships)
          AND (r.GBDR_level = "SMDL" OR r.nodeSimilarity >= .75)
          AND NOT (type(r) IN ["CONNECTED_BY","CONNECTED_TO","connected by","connects to"])
       )
 AND ALL(n in nodes(results)
          WHERE n:SMDL
            AND(
              (NOT n IN (boundaryNodes))
              OR n IN (matchedNodes)
              OR (insideNode IN (matchedNodes) AND endNode IN (matchedNodes)))
        )
 return COLLECT(results) AS results}
 WITH results
 CALL{
     WITH results
     UNWIND results as SMresults
     WITH nodes(SMresults) AS rNodes
     UNWIND rNodes as rNodes2
     WITH DISTINCT rNodes2 as rNodes ORDER BY rNodes.id
     RETURN COLLECT(rNodes) as rNodes
 }
 WITH rNodes, results
 CALL{
     WITH results
     UNWIND results as SMresults
     WITH relationships(SMresults) AS rRelationships
     UNWIND rRelationships as rRelationships2
     WITH DISTINCT rRelationships2 as rRelationships ORDER BY rRelationships.id
     RETURN COLLECT(rRelationships) as rRelationships
}
RETURN rNodes, rRelationships


//Use Case #23
PROFILE
CALL {
OPTIONAL MATCH ()-[a:TEMP_SEARCH_REL]-()
DELETE a RETURN "done" as temp2
} WITH "1" as temp LIMIT 1
CALL {
OPTIONAL MATCH (b:WINNOW)
REMOVE b:WINNOW RETURN "done" as temp2
} WITH "1" as temp LIMIT 1

WITH COLLECT(temp) AS temp

CALL {
 MATCH boundary = (insideNode:SMDL) WHERE insideNode.name IN ["electrical energy","Electrical Energy"]
 SET insideNode.winnowCriteria = 1 SET insideNode:WINNOW
 RETURN boundary, insideNode
 UNION
 MATCH boundary = (insideNode:SMDL) WHERE insideNode.name IN ["battery","Battery","accumulator"]
 SET insideNode.winnowCriteria = 2 SET insideNode:WINNOW
 RETURN boundary, insideNode
}
WITH boundary, insideNode
WITH COLLECT(boundary) AS boundaryset, COLLECT(insideNode) AS insideNodes
UNWIND (boundaryset) AS boundary
UNWIND
  CASE
    WHEN relationships(boundary) = [] THEN [null]
    ELSE relationships(boundary)
  END AS bRels
UNWIND nodes(boundary) as bNodes
WITH COLLECT(bRels) as boundaryRelationships, COLLECT(bNodes) AS boundaryNodes, insideNodes, insideNodes as insideNodes2
UNWIND insideNodes AS insideNode
UNWIND insideNodes2 as insideNodeCart //Cart = cartesian

MATCH results=shortestPath((insideNode)-[*1..]-(insideNodeCart))
  WHERE
  insideNode <> insideNodeCart
  //BLACKLIST CRITERIA LIMIT WAYS THAT SYSTEM MODELS CAN BE CONNECTED
  AND ALL(r in relationships(results)
           WHERE
           NOT (r IN boundaryRelationships)
           AND (r.GBDR_level = "SMDL")
           AND NOT type(r) IN ["CONNECTED_BY","CONNECTED_TO","connected by","connects to"]
        )
  AND ALL(n in nodes(results)
           WHERE
            n:SMDL
         )
  AND id(insideNode) > id(insideNodeCart)

CREATE (insideNode)-[:TEMP_SEARCH_REL]->(insideNodeCart)
WITH boundaryNodes LIMIT 1

MATCH hyperboundary = (a1:WINNOW{winnowCriteria:1})-[:TEMP_SEARCH_REL]-(a2:WINNOW) WHERE a2.winnowCriteria <> 1
WITH hyperboundary, nodes(hyperboundary) AS bounds1to2, boundaryNodes
UNWIND bounds1to2 as bounds1to2uw
WITH DISTINCT bounds1to2uw, COLLECT(bounds1to2) as bounds1to2coll, boundaryNodes
MATCH (SM:System_Model)<-[:IS_CHILD_OF]-(bounds1to2uw)
UNWIND bounds1to2coll as bounds1to2
WITH DISTINCT SM, bounds1to2, boundaryNodes ORDER BY SM
WITH COLLECT(SM) AS modelset, bounds1to2, boundaryNodes
WITH DISTINCT modelset, boundaryNodes
WITH COLLECT(modelset) AS allModels, boundaryNodes

MATCH ()-[relA:TEMP_SEARCH_REL]-()
DELETE relA
WITH allModels, boundaryNodes LIMIT 1

CALL
{
  WITH allModels
  UNWIND allModels as modellist
  UNWIND modellist as SMincluded
  WITH DISTINCT SMincluded as SMincluded
  MATCH (smNodes:SMDL)-[:IS_CHILD_OF]->(SMincluded)
  WITH COLLECT(smNodes) AS nodeSet
  UNWIND nodeSet as smNodes
  WITH smNodes, nodeSet ORDER BY smNodes
  MATCH relPat = (smNodes)-[smRels]->(n) WHERE n IN (nodeSet)
  SET smRels.WINNOW_WEIGHT = 0
  FOREACH (i in CASE WHEN (((NOT smNodes:SMDL) OR smNodes.name IN ['rotor','lift'])) THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + .5)
  FOREACH (i in CASE WHEN (((NOT n:SMDL) OR n.name IN ['motor'])) THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + .5)
  FOREACH (i in CASE WHEN (type(smRels) IN ["CONNECTED_BY","CONNECTED_TO","connected by","connects to","DECOMPOSED_BY","DECOMPOSES","decomposed by","decomposes"]) THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + .5)
  FOREACH (i in CASE WHEN (type(smRels) = "POTENTIAL_MATCH") THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + 5)
  RETURN relPat LIMIT 1
}

WITH allModels, boundaryNodes
UNWIND allModels AS modelset
WITH modelset, boundaryNodes

//for each set of model nodes that will be returned, at this step we have the set of system models that are combined for EACH result, and a list of ALL boundary nodes


CALL
{
    WITH modelset, boundaryNodes
    WITH modelset AS SMlist, boundaryNodes as totalBList
    UNWIND totalBList as relevantBoundary
    UNWIND SMlist as SMset
    UNWIND SMset AS SMparent
    MATCH (SMparent)<-[:IS_CHILD_OF]-(relevantBoundary)
    WITH DISTINCT relevantBoundary AS relBounds, SMset
    WITH COLLECT(relBounds) AS relBounds, SMset
    WITH COLLECT(relBounds) AS relBounds, COLLECT(SMset) as SMset

    CALL{
      WITH relBounds
      UNWIND relBounds as rb2
      WITH DISTINCT rb2 as rb2
      UNWIND rb2 as relevantCriteriaNodes
      UNWIND rb2 as otherCriteriaNodes
      WITH relevantCriteriaNodes, otherCriteriaNodes WHERE relevantCriteriaNodes <> otherCriteriaNodes
      CALL apoc.algo.dijkstra(otherCriteriaNodes, relevantCriteriaNodes, '', 'WINNOW_WEIGHT',10) YIELD path, weight
      RETURN path AS relPaths
    }
    WITH COLLECT(relPaths) AS relPaths, relBounds as relBoundsCol, SMset AS SMsetCol
    UNWIND SMsetCol as SMset
    UNWIND relBoundsCol as relBounds
    UNWIND SMset AS SMparent
    MATCH (SMparent)<-[:IS_CHILD_OF]-(allNodes)
    WITH relBounds, allNodes, relPaths

    CALL{
      WITH relBounds, allNodes
      UNWIND relBounds as relevantCriteriaNodes
      WITH allNodes as whiteListNode, relevantCriteriaNodes WHERE whiteListNode <> relevantCriteriaNodes
      CALL apoc.algo.dijkstra(whiteListNode, relevantCriteriaNodes, '', 'WINNOW_WEIGHT',10) YIELD path, weight
      RETURN path AS sPath ORDER BY weight ASC LIMIT 1
    }
    WITH sPath,relPaths
    WITH COLLECT(sPath) as allPaths, relPaths
    UNWIND allPaths AS sPath
    UNWIND nodes(sPath) as pathNodes
    WITH DISTINCT(pathNodes) AS reqNodes, allPaths, relPaths
    WITH COLLECT(reqNodes) AS reqNodes, allPaths, relPaths
    UNWIND reqNodes AS firstCut
    MATCH secondcut=(firstCut)-[{WINNOW_WEIGHT:0}]-()
    WITH COLLECT(secondcut)+allPaths+relPaths AS allPaths
    UNWIND allPaths as bothCuts
    WITH COLLECT(DISTINCT bothCuts) AS allPaths
    UNWIND allPaths AS sPathUW
    UNWIND nodes(sPathUW) as pathNodes
    WITH DISTINCT(pathNodes) AS reqNodes, allPaths
    WITH COLLECT(reqNodes) AS reqNodes, allPaths
    UNWIND allPaths as sPath
    UNWIND relationships(sPath) as pathRels
    WITH COLLECT(DISTINCT(pathRels)) as reqRels, reqNodes
    RETURN reqRels, reqNodes
}
RETURN reqRels, reqNodes, SIZE(reqNodes) as nodeCount




//Use Case #24
PROFILE
CALL {
OPTIONAL MATCH ()-[a:TEMP_SEARCH_REL]-()
DELETE a RETURN "done" as temp2
} WITH "1" as temp LIMIT 1
CALL {
OPTIONAL MATCH (b:WINNOW)
REMOVE b:WINNOW RETURN "done" as temp2
} WITH "1" as temp LIMIT 1

WITH COLLECT(temp) AS temp

CALL {
 MATCH boundary = (insideNode:SMDL) WHERE insideNode.name IN ["electrical energy","Electrical Energy"]
 SET insideNode.winnowCriteria = 1 SET insideNode:WINNOW
 RETURN boundary, insideNode
 UNION
 MATCH boundary = (insideNode:SMDL) WHERE insideNode.name IN ["battery","Battery","accumulator"]
 SET insideNode.winnowCriteria = 2 SET insideNode:WINNOW
 RETURN boundary, insideNode
 UNION
 MATCH boundary = (insideNode:SMDL{name:'heat'})
 SET insideNode.winnowCriteria = 3 SET insideNode:WINNOW
 RETURN boundary, insideNode
}
WITH boundary, insideNode
WITH COLLECT(boundary) AS boundaryset, COLLECT(insideNode) AS insideNodes
UNWIND (boundaryset) AS boundary
UNWIND
  CASE
    WHEN relationships(boundary) = [] THEN [null]
    ELSE relationships(boundary)
  END AS bRels
UNWIND nodes(boundary) as bNodes
WITH COLLECT(bRels) as boundaryRelationships, COLLECT(bNodes) AS boundaryNodes, insideNodes, insideNodes as insideNodes2
UNWIND insideNodes AS insideNode
UNWIND insideNodes2 as insideNodeCart //Cart = cartesian

MATCH results=shortestPath((insideNode)-[*1..]-(insideNodeCart))
  WHERE
  insideNode <> insideNodeCart
  //BLACKLIST CRITERIA LIMIT WAYS THAT SYSTEM MODELS CAN BE CONNECTED
  AND ALL(r in relationships(results)
           WHERE
           NOT (r IN boundaryRelationships)
           AND (r.GBDR_level = "SMDL" OR type(r) = 'POTENTIAL_MATCH')
           AND NOT type(r) IN ["CONNECTED_BY","CONNECTED_TO","connected by","connects to"]
        )
  AND ALL(n in nodes(results)
           WHERE
            n:SMDL
         )
  AND id(insideNode) > id(insideNodeCart)
CREATE (insideNode)-[:TEMP_SEARCH_REL]->(insideNodeCart)
WITH boundaryNodes LIMIT 1


MATCH hyperboundary = (a1:WINNOW{winnowCriteria:1})-[:TEMP_SEARCH_REL]-(a2:WINNOW) WHERE a2.winnowCriteria <> 1
WITH hyperboundary, nodes(hyperboundary) AS bounds1to2, boundaryNodes
UNWIND bounds1to2 as nodes1to2
MATCH hyperboundary2 = (nodes1to2)-[:TEMP_SEARCH_REL]-(b2:WINNOW)
WHERE
b2.winnowCriteria <> 1
AND ALL(n in nodes(hyperboundary) WHERE n.winnowCriteria <> b2.winnowCriteria)
WITH nodes(hyperboundary) + nodes(hyperboundary2) AS bounds1to3, boundaryNodes
UNWIND bounds1to3 AS bounds1to3uw
WITH DISTINCT bounds1to3uw, COLLECT(bounds1to3) as bounds1to3coll, boundaryNodes
MATCH (SM:System_Model)<-[:IS_CHILD_OF]-(bounds1to3uw)
UNWIND bounds1to3coll as bounds1to3
WITH DISTINCT SM, bounds1to3, boundaryNodes ORDER BY SM
WITH COLLECT(SM) AS modelset, bounds1to3, boundaryNodes
WITH DISTINCT modelset, boundaryNodes
WITH COLLECT(modelset) AS allModels, boundaryNodes

MATCH ()-[relA:TEMP_SEARCH_REL]-()
DELETE relA
WITH allModels, boundaryNodes LIMIT 1

CALL
{
  WITH allModels
  UNWIND allModels as modellist
  UNWIND modellist as SMincluded
  WITH DISTINCT SMincluded as SMincluded
  MATCH (smNodes:SMDL)-[:IS_CHILD_OF]->(SMincluded)
  WITH COLLECT(smNodes) AS nodeSet
  UNWIND nodeSet as smNodes
  WITH smNodes, nodeSet ORDER BY smNodes
  MATCH relPat = (smNodes)-[smRels]->(n) WHERE n IN (nodeSet)
  SET smRels.WINNOW_WEIGHT = 0
  FOREACH (i in CASE WHEN (((NOT smNodes:SMDL) OR smNodes.name IN ['rotor','lift'])) THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + .5)
  FOREACH (i in CASE WHEN (((NOT n:SMDL) OR n.name IN ['motor'])) THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + .5)
  FOREACH (i in CASE WHEN (type(smRels) IN ["CONNECTED_BY","CONNECTED_TO","connected by","connects to","DECOMPOSED_BY","DECOMPOSES","decomposed by","decomposes"]) THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + .5)
  FOREACH (i in CASE WHEN (type(smRels) = "POTENTIAL_MATCH") THEN [1] ELSE [] END |
  SET smRels.WINNOW_WEIGHT = smRels.WINNOW_WEIGHT + 5)
  RETURN relPat LIMIT 1
}

WITH allModels, boundaryNodes
UNWIND allModels AS modelset
WITH modelset, boundaryNodes

//for each set of model nodes that will be returned, at this step we have the set of system models that are combined for EACH result, and a list of ALL boundary nodes


CALL
{
    WITH modelset, boundaryNodes
    WITH modelset AS SMlist, boundaryNodes as totalBList
    UNWIND totalBList as relevantBoundary
    UNWIND SMlist as SMset
    UNWIND SMset AS SMparent
    MATCH (SMparent)<-[:IS_CHILD_OF]-(relevantBoundary)
    WITH DISTINCT relevantBoundary AS relBounds, SMset
    WITH COLLECT(relBounds) AS relBounds, SMset
    WITH COLLECT(relBounds) AS relBounds, COLLECT(SMset) as SMset

    CALL{
      WITH relBounds
      UNWIND relBounds as rb2
      WITH DISTINCT rb2 as rb2
      UNWIND rb2 as relevantCriteriaNodes
      UNWIND rb2 as otherCriteriaNodes
      WITH relevantCriteriaNodes, otherCriteriaNodes WHERE relevantCriteriaNodes <> otherCriteriaNodes
      CALL apoc.algo.dijkstra(otherCriteriaNodes, relevantCriteriaNodes, '', 'WINNOW_WEIGHT',10) YIELD path, weight
      RETURN path AS relPaths
    }
    WITH COLLECT(relPaths) AS relPaths, relBounds as relBoundsCol, SMset AS SMsetCol
    UNWIND SMsetCol as SMset
    UNWIND relBoundsCol as relBounds
    UNWIND SMset AS SMparent
    MATCH (SMparent)<-[:IS_CHILD_OF]-(allNodes)
    WITH relBounds, allNodes, relPaths

    CALL{
      WITH relBounds, allNodes
      UNWIND relBounds as relevantCriteriaNodes
      WITH allNodes as whiteListNode, relevantCriteriaNodes WHERE whiteListNode <> relevantCriteriaNodes
      CALL apoc.algo.dijkstra(whiteListNode, relevantCriteriaNodes, '', 'WINNOW_WEIGHT',10) YIELD path, weight
      RETURN path AS sPath ORDER BY weight ASC LIMIT 1
    }
    WITH sPath,relPaths
    WITH COLLECT(sPath) as allPaths, relPaths
    UNWIND allPaths AS sPath
    UNWIND nodes(sPath) as pathNodes
    WITH DISTINCT(pathNodes) AS reqNodes, allPaths, relPaths
    WITH COLLECT(reqNodes) AS reqNodes, allPaths, relPaths
    UNWIND reqNodes AS firstCut
    MATCH secondcut=(firstCut)-[{WINNOW_WEIGHT:0}]-()
    WITH COLLECT(secondcut)+allPaths+relPaths AS allPaths
    UNWIND allPaths as bothCuts
    WITH COLLECT(DISTINCT bothCuts) AS allPaths
    UNWIND allPaths AS sPathUW
    UNWIND nodes(sPathUW) as pathNodes
    WITH DISTINCT(pathNodes) AS reqNodes, allPaths
    WITH COLLECT(reqNodes) AS reqNodes, allPaths
    UNWIND allPaths as sPath
    UNWIND relationships(sPath) as pathRels
    WITH COLLECT(DISTINCT(pathRels)) as reqRels, reqNodes
    RETURN reqRels, reqNodes
}
RETURN reqRels, reqNodes, SIZE(reqNodes) as nodeCount
