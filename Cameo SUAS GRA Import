//Alternative Approach:

//Filename = SUAS Reference Architecture 11 Mar 2021

//Step 0: Import and Pre-processing of XML file content.

//Step 0.1: Import XML file from local directory.
//The below paths must be updated to meet user directory structure and file location
call apoc.xml.import("file:///Users/danie/.Neo4jDesktop/neo4jDatabases/database-b2c772db-f121-42a9-92d8-915048491c98/installation-4.3.5/import/SUAS Reference Architecture 11 Mar 2021.xml",{filterLeadingWhitespace:true,delimiter:"X0Y9A8B7"}) yield node
return "done";

//Step 0.2: Remove relationships generated by APOC XML Import procedure that aren't used in the GBDR.
MATCH (a)-[n]->(b) WHERE (a:XmlDocument OR a:XmlCharacters OR a:XmlTag) AND type(n) <> 'IS_CHILD_OF' DELETE n;

//Step 0.3: Rebadge Nodes with uml:XXXX labels to just XXXX
MATCH (a:XmlTag)
WITH a, collect(left(a.type,3)) AS left_type
UNWIND(left_type) as left_type_uw
WITH a WHERE left_type_uw = 'uml'
WITH a, collect(substring(a.type,4)) AS node_type
CALL apoc.create.addLabels(a,node_type) YIELD node
REMOVE node:XmlTag
WITH node
UNWIND labels(node) as labels_list
RETURN DISTINCT labels_list, count(labels_list);

MATCH(a:XmlTag)
WITH a, collect(a._name) AS node_name
CALL apoc.create.addLabels(a,node_name) YIELD node
REMOVE node:XmlTag;

//Step 0.4 Move XML text value content to the tag it belongs to - this may be bringing in a reference and losing context
MATCH (text_nodes:XmlCharacters)-[:IS_CHILD_OF]->(parent_node)
SET parent_node.text_value = text_nodes.text
DETACH DELETE text_nodes;

//Step 1.0 Identify all cross references in subgraph of interest
PROFILE
MATCH (a)
WITH collect(a.id) AS id_list
MATCH (top_node:Package{name:'UAS Physical Model-Fixed Wing'})<-[:IS_CHILD_OF*0..]-(node)
UNWIND keys(node) as key_list
WITH node, key_list, id_list WHERE key_list <> 'id'
WITH node, node[key_list] as linkedNodeId, key_list WHERE node[key_list] IN id_list
SET node:GBDR_REF_SOURCE
WITH DISTINCT linkedNodeId
WITH collecT(linkedNodeId) AS linkedNodeId LIMIT 1
MATCH (referencedNode) WHERE referencedNode.id IN linkedNodeId
MATCH (sourceNode:GBDR_REF_SOURCE)
    WHERE ANY(property in keys(sourceNode) WHERE sourceNode[property] = referencedNode.id AND property<>'id')
UNWIND keys(sourceNode) as key_list
WITH sourceNode, referencedNode, key_list WHERE sourceNode[key_list] = referencedNode.id
MERGE (sourceNode)-[:GBDR_MODEL_CROSS_REF {ref_property:[key_list]}]->(referencedNode);
MATCH (a:GBDR_REF_SOURCE) REMOVE a:GBDR_REF_SOURCE;

//Step 1.1 Cross references for used elements (diagram references) updated
MATCH p=(parent_Diagram:Diagram)<-[:IS_CHILD_OF*0..]-()-[xref:GBDR_MODEL_CROSS_REF {ref_property:['text_value']} ]->(referencedElement)
MERGE (parent_Diagram)-[:USES]->(referencedElement)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.2 Cross references for diagram ownership changed to relationships
MATCH (sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode) WHERE xref.GBDR_PROCESSED IS NULL
AND xref.ref_property = ['ownerOfDiagram']
MERGE (sourceNode)-[:OWNED_BY {GBDR_level:'SMDL'}]->(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.3 Cross references for slots changed to relationships between specified values, meaning, and subject elements
//Step 1.3.1 Single value definingFeatures
MATCH (top_node:Package{name:'UAS Physical Model-Fixed Wing'})<-[:IS_CHILD_OF*0..]-(parentNode)<-[:IS_CHILD_OF]-(slot:Slot)-[xref:GBDR_MODEL_CROSS_REF]->(valueMeaning)
WHERE xref.GBDR_PROCESSED IS NULL
OPTIONAL MATCH (slot)<-[:IS_CHILD_OF]-(slotValue) WHERE NOT slotValue:InstanceValue
SET xref.GBDR_PROCESSED = 'true'
MERGE (slotValue)-[:DESCRIBES {GBDR_level:'SMDL'}]->(parentNode)
MERGE (slotValue)<-[:SPECIFIED_BY {GBDR_level:'SMDL'}]-(valueMeaning);

//Step 1.3.2 Complex definingFeatures
MATCH (top_node:Package{name:'UAS Physical Model-Fixed Wing'})<-[:IS_CHILD_OF*0..]-(parentNode)<-[:IS_CHILD_OF]-(slot:Slot)<-[:IS_CHILD_OF]-(slotValue:InstanceValue)
MERGE (slotValue)-[:DESCRIBES {GBDR_level:'SMDL'}]->(parentNode)
WITH DISTINCT parentNode,  slot,slotValue
OPTIONAL MATCH (slotValue)-[xref:GBDR_MODEL_CROSS_REF]->(instanceValue) //Optional needed?
MERGE (slotValue)<-[:DEFINED_BY {GBDR_level:'SMDL'}]-(instanceValue)
SET xref.GBDR_PROCESSED = 'true'
WITH DISTINCT parentNode, slot, slotValue
OPTIONAL MATCH (slot)-[xref2:GBDR_MODEL_CROSS_REF]->(valueMeaning)
MERGE (slotValue)<-[:SPECIFIED_BY {GBDR_level:'SMDL'}]-(valueMeaning)
SET xref2.GBDR_PROCESSED = 'true';

//Step 1.4 Cross references for source and target of control flows changed to relationships between nodes and edges
MATCH p=(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode) WHERE xref.GBDR_PROCESSED IS NULL
AND xref.ref_property = ["source"]
MERGE (sourceNode)<-[:SOURCE_OF {GBDR_level:'SMDL'}]-(referencedNode)
SET xref.GBDR_PROCESSED = 'true';
MATCH p=(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode) WHERE xref.GBDR_PROCESSED IS NULL
AND xref.ref_property = ["target"]
MERGE (sourceNode)-[:TARGETS {GBDR_level:'SMDL'}]->(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.5 Cross references for min,max,instance changed to relationships
MATCH p=(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode) WHERE xref.GBDR_PROCESSED IS NULL
AND (xref.ref_property = ["min"] OR xref.ref_property = ["max"] OR xref.ref_property = ["instance"] )
MERGE (sourceNode)<-[:DEFINED_BY {GBDR_level:'SMDL'}]-(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.6 Cross references related to connectors changed to relationships between connected ends
MATCH (connectorNode)<-[:IS_CHILD_OF]-(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode)-[:IS_CHILD_OF]->(end_node)
WHERE xref.GBDR_PROCESSED IS NULL
AND (xref.ref_property = ["role"] OR xref.ref_property = ["partWithPort"])
SET xref.GBDR_PROCESSED = 'true'
WITH DISTINCT connectorNode,end_node
MERGE (connectorNode)<-[:CONNECTED_BY {GBDR_level:'SMDL'}]-(end_node);

//Step 1.7 Depricated references and unused diagram context rcross references are processed with no changes to graph structure
MATCH p=(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode)
WHERE xref.GBDR_PROCESSED IS NULL
AND (xref.ref_property = ["originalID"] OR xref.ref_property = ["context"])
SET xref.GBDR_PROCESSED = 'true'
SET xref.GBDR_PROCESSED_NOTES = 'not needed for GBDR purposes';

//Step 1.8 Specification cross references changed to links
MATCH p=(instanceNode)<-[:IS_CHILD_OF]-(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(generalNode) WHERE xref.GBDR_PROCESSED IS NULL
AND xref.ref_property = ["general"]
SET xref.GBDR_PROCESSED = 'true'
MERGE (instanceNode)-[:SPECIFIES {GBDR_level:'SMDL'}]->(generalNode);

//Step 1.9 ExtendedCase references changed to relationships
MATCH p=(childNode)<-[:IS_CHILD_OF]-(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode)
WHERE
xref.GBDR_PROCESSED IS NULL AND
xref.ref_property = ["extendedCase"]
MERGE (childNode)-[:EXTENDS {GBDR_level:'SMDL'}]->(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.10 BehaviorClassifier cross references changed to relationships
MATCH (sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode)
WHERE xref.GBDR_PROCESSED IS NULL
AND xref.ref_property = ["classifierBehavior"]
MERGE (sourceNode)<-[:DESCRIBES {GBDR_level:'SMDL'}]-(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.11 Included use case cross references changed to relationships
MATCH (childNode)<-[:IS_CHILD_OF]-(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode) WHERE xref.GBDR_PROCESSED IS NULL
AND xref.ref_property = ["addition"]
MERGE (childNode)<-[:INCLUDES {GBDR_level:'SMDL'}]-(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.12 Action cross references to invoked behavior changed to connections
MATCH (sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode) WHERE xref.GBDR_PROCESSED IS NULL
AND xref.ref_property = ["behavior"]
MERGE (sourceNode)-[:INVOKES {GBDR_level:'SMDL'}]->(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.13 Type Inheritance Cross references changed to relationships
MATCH p=(sourceNode)-[xref:GBDR_MODEL_CROSS_REF]->(referencedNode)
WHERE
xref.GBDR_PROCESSED IS NULL AND
xref.ref_property = ["type"] and
sourceNode.name IS NOT NULL
MERGE (sourceNode)-[b:TYPE_OF {GBDR_level:'SMDL'}]->(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 1.14 Property cross references to aggregated associations changed to direct relationships
MATCH p=(parentNode1)<-[xref1b:GBDR_MODEL_CROSS_REF]-(ownedEnd1)-[xref1a:GBDR_MODEL_CROSS_REF]->(assoc:Association)<-[xref2a:GBDR_MODEL_CROSS_REF]-(ownedEnd2)-[xref2b:GBDR_MODEL_CROSS_REF]->(childNode2)
WHERE xref2a.GBDR_PROCESSED IS NULL
AND xref1a.ref_property = ["association"]
AND xref1b.ref_property = ["type"]
AND xref2a.ref_property = ["association"]
AND xref2b.ref_property = ["type"]
MATCH (ownedEnd2)-[:IS_CHILD_OF]->(parentNode1)
MERGE (childNode2)-[r:DECOMPOSES {GBDR_level:'SMDL'}]->(parentNode1)
SET xref1a.GBDR_PROCESSED = 'true'
SET xref1b.GBDR_PROCESSED = 'true'
SET xref2a.GBDR_PROCESSED = 'true'
SET xref2b.GBDR_PROCESSED = 'true';

//Step 1.15 Property cross references to undirected associations changed to direct relationships
MATCH p=(parentNode1)<-[xref1b:GBDR_MODEL_CROSS_REF]-(ownedEnd1)-[xref1a:GBDR_MODEL_CROSS_REF]->(assoc:Association)<-[xref2a:GBDR_MODEL_CROSS_REF]-(ownedEnd2)-[xref2b:GBDR_MODEL_CROSS_REF]->(childNode2)
WHERE xref2a.GBDR_PROCESSED IS NULL
AND xref1a.ref_property = ["association"]
AND xref1b.ref_property = ["type"]
AND xref2a.ref_property = ["association"]
AND xref2b.ref_property = ["type"]
OPTIONAL MATCH (ownedEnd2)-[:IS_CHILD_OF]->(parentNode2)
WHERE parentNode2<>parentNode1
MERGE (childNode2)-[:ASSOCIATED_WITH {GBDR_level:'SMDL'}]->(parentNode1)
SET xref1a.GBDR_PROCESSED = 'true'
SET xref1b.GBDR_PROCESSED = 'true'
SET xref2a.GBDR_PROCESSED = 'true'
SET xref2b.GBDR_PROCESSED = 'true';

//Step 1.16 Abstraction cross links/dependencies between client and supplier changed to relationships
MATCH p =(parent:Abstraction)<-[:IS_CHILD_OF]-(:client)-[xRef1:GBDR_MODEL_CROSS_REF]->(clientNode)
MATCH p2=(parent)<-[:IS_CHILD_OF]-(:supplier)-[xRef2:GBDR_MODEL_CROSS_REF]->(supplierNode)
WHERE xRef1.GBDR_PROCESSED IS NULL
AND xRef2.GBDR_PROCESSED IS NULL
MERGE(clientNode)-[:DEPENDS_ON {GBDR_level:'SMDL'}]->(supplierNode)
SET xRef1.GBDR_PROCESSED='true'
SET xRef2.GBDR_PROCESSED='true';

//Step 1.17 Element "idref" cross references changed to relationships
MATCH p=(parentNode)<-[:IS_CHILD_OF]-(sourceNode)-[xref:GBDR_MODEL_CROSS_REF ]->(referencedNode)
WHERE
xref.GBDR_PROCESSED IS NULL AND
xref.ref_property = ["idref"] AND
sourceNode.association IS NULL
MERGE (sourceNode)-[:REFERENCES {GBDR_level:'SMDL'}]->(referencedNode)
SET xref.GBDR_PROCESSED = 'true';

//Step 2.0 Tag list for remaining steps
MATCH (barrier)<-[:IS_CHILD_OF]-(top_node:Package{name:'UAS Physical Model-Fixed Wing'})
CALL apoc.path.subgraphAll(top_node, {
    relationshipFilter: "IS_CHILD_OF",
    minLevel: 0,
    maxLevel: 50,
    blacklistNodes: [barrier]
})
YIELD nodes, relationships
UNWIND nodes as nodelist
SET nodelist:SUBGRAPH_RESULT
RETURN count(nodelist);


//Step 2.1 Inherit classes from parent as necessary (class and activity) <-might not need this
MATCH p=(a:SUBGRAPH_RESULT:ownedAttribute)-[:IS_CHILD_OF]->(b)
WHERE a.name IS NOT NULL
call apoc.create.addLabels(a,labels(b)) yield node
WITH node as a
call apoc.create.removeLabels(a,['ownedAttribute']) yield node
RETURN "done";

//Step 2.2 Properties changed from child_of to SMDL

MATCH (sourceNode:Property:SUBGRAPH_RESULT)-[:IS_CHILD_OF]->(referencedNode)
MERGE (sourceNode)-[:DESCRIBES {GBDR_level:'SMDL'}]->(referencedNode);

//Step 2.3 Removes GBDR_MODEL_CROSS_REF rRelationships
MATCH p=(:SUAS_GRA)-[rel1:GBDR_MODEL_CROSS_REF]-(:SUAS_GRA)
DELETE rel1;





//DONT INCLUDE BELOW IN APPENDIX


//For use in regular GBDR - sets synthesis flag
MATCH p=(a:SUBGRAPH_RESULT)-[ref{GBDR_level:'SMDL'}]-(b:SUBGRAPH_RESULT)
WHERE (a:Class OR a:Activity OR a:Actor OR a:UseCase)
AND (b:Class OR b:Property OR b:Activity OR b:Actor OR b:UseCase)
WITH DISTINCT a
SET a:SYNTHESIS_FLAG;

MERGE (sys:System_Model{name:'SUAS GRA'})
WITH sys LIMIT 1
MATCH (a:SYNTHESIS_FLAG)
MERGE (a)-[:IS_CHILD_OF]->(sys);
MATCH (a:SYNTHESIS_FLAG) SET a.GBDR_level = "SMDL" SET a:SUAS_GRA;
