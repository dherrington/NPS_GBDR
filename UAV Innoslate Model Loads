//CREATE EXAMPLE SYSTEM MODEL Q-093

          //Import Algorithm for Innoslate System Model from Local Drive to Neo4j GBDR.
          //Step 0: Import and Pre-processing of XML file content.
          //Step 0.1: Import XML file from local director.
          call apoc.xml.import("file:///Users/danie/.Neo4jDesktop/neo4jDatabases/database-b2c772db-f121-42a9-92d8-915048491c98/installation-4.3.5/import/Q-093_UAV_System_Model.xml",{filterLeadingWhitespace:true,delimiter:"X0Y9A8B7"}) yield node
          return "done";

          //Step 0.2: Remove relationships generated by APOC XML Import procedure that aren't used in the GBDR.
          MATCH (a)-[n]->(b) WHERE (a:XmlDocument OR a:XmlCharacters OR a:XmlTag) AND type(n) <> 'IS_CHILD_OF' DELETE n;

          //Step 0.3: Transform uniqueProjectId and children nodes from separate nodes to labeled properties.
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT model_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH model_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(model_node,prop_name,prop_text2) YIELD node
          RETURN node;
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 0.4: Create additional labels for immediate children nodes of root content node (where name is 'innoslate').
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*1..2]-(child_node)
          WITH child_node, collect(child_node._name) AS node_name
          CALL apoc.create.addLabels(child_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 0.5: (Document level subgraph cleanup) Remove 'XmlTag' label and add 'Model_Package' label.
          MATCH(a:XmlTag {_name:"innoslate"})
          SET a:Model_Package
          REMOVE a:XmlTag;

          //Step 1.0: Generate ODL subgraph from 'schema' sub-graph.

          //Step 1.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(child_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT child_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH child_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(child_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'ODL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 1.2: Change node labels from 'XmlTag' to 'SchemaClass' and 'SchemaRelation'.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(end_node:XmlTag)
          WITH end_node, collect(end_node._name) AS node_name
          CALL apoc.create.addLabels(end_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 1.3: Create edges between connected schemaClass nodes using Id references.
          MATCH (schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF]-(rels:xmlTargetRelation)
          MATCH (a:schemaClass) WHERE a.id = rels.sourceId
          OPTIONAL MATCH (b:schemaClass) WHERE b.id = rels.targetId
          OPTIONAL MATCH (c:schemaRelation) WHERE c.id = rels.relationId
          CREATE(a)-[:source_of {GBDR_level:"ODL"}]->(c)
          CREATE(b)-[:target_of {GBDR_level:"ODL"}]->(c)
          DETACH DELETE rels;

          //Step 1.4: ODL subgraph cleanup ('schema' subgraph of XML import graph).

          //Step 1.4.1: Change label of node named 'schema' from 'XmlTag' to 'Ontology'.
          MATCH (schema:XmlTag {_name:"schema"})
          SET schema:Ontology
          REMOVE schema:XmlTag;

          //Step 1.4.2: Change relationship between schemaProperty nodes and schemaClass nodes to 'defined_by'.
          MATCH (a:schemaProperty)-[r:IS_CHILD_OF]->(b) WHERE b:schemaClass OR b:schemaRelation
          CREATE (a)<-[:defined_by {GBDR_level:"ODL"}]-(b)
          WITH r DELETE r;

          //Step 1.4.3: Create subclass relationship between parent and child classes.
          MATCH (child:schemaClass)
          MATCH (parent:schemaClass {id:child.parentId})
          CREATE (child)-[:subclass_of {GBDR_level:"ODL"}]->(parent);

          //Step 1.4.4: Create inverse relationship schemaRelations to reflect inverseRelationId.
          MATCH(r1:schemaRelation)
          MATCH(r2:schemaRelation {id:r1.inverseRelationId})
          CREATE (r1)-[:Inverse_of]->(r2);

          //Step 2.0: Generate SMDL subgraph from 'database' sub-graph of XML import graph.

          //Step 2.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 2.2: Change entity node labels from 'XmlTag' to value of 'name' property of referenced schemaClass node.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent {_name:'entity'})
          MATCH(sClass:schemaClass {id:ent.schemaClassId})
          WITH ent, collect(sClass.name) AS node_name
          CALL apoc.create.addLabels(ent,node_name) YIELD node
          SET ent:entity
          REMOVE ent:XmlTag;

          //Step 2.3: Transform relationships from nodes to edges.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(rels {_name:'relationship'})
          MATCH(target:entity {globalId:rels.targetId})
          MATCH(source:entity {globalId:rels.sourceId})
          MATCH(sRel:schemaRelation {id:rels.schemaRelationId})
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF]-(rels_link:XmlTag {_name:"booleanAttribute"})
          OPTIONAL MATCH (sProp:schemaProperty {id:rels_link.schemaPropertyId})
          WITH DISTINCT rels, rels_link, source, sRel.name as rel_name, target, sProp.name as prop_name, rels_link.booleanValue as prop_value
          CALL apoc.create.relationship(source,rel_name,{GBDR_level:"SMDL"},target) YIELD rel as rel1
          WITH rels, rels_link, rel1, prop_name, prop_value
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF*]-(rels_props)
          DETACH DELETE rels_props, rels
          WITH rel1, rels_link, prop_name, prop_value WHERE prop_name IS NOT NULL
          CALL apoc.create.setRelProperty(rel1,prop_name,prop_value) YIELD rel AS rel2
          DETACH DELETE rels_link;

          //Step 2.4: SMDL subgraph cleanup ('database' subgraph of XML import graph).

          //Step 2.4.1: Change distribution attribute children node labels from 'XmlTag' to 'distribution'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'distribution'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DISTRIBUTION
          SET nestedprops:DISTRIBUTION
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'

          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.2: Change simulation data attribute children node labels from 'XmlTag' to 'SIMDATA'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'simulationData'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:SIMDATA
          SET nestedprops:SIMDATA
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.3: Change diagram metadata node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'metadata'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.4: Change diagram node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'xmlDiagram'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.5: Change complex attribute node labels 'XmlTags' nodes to 'NestedProperty'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag) WHERE m1prop._name IN ["dateAttribute", "doubleAttribute", "durationAttribute", "stringAttribute", "numberAttribute", "qualityAttribute"
          ]
          MATCH (sProp:schemaProperty {id:m1prop.schemaPropertyId})
          SET m1prop:Nested_Property
          SET m1prop.property_name = sProp.name
          REMOVE m1prop:XmlTag;
          MATCH (nestedProps:Nested_Property)-[:IS_CHILD_OF]->(parentNode)
          SET nestedProps.GBDR_value = coalesce(nestedProps.value,nestedProps.doubleValue,nestedProps.booleanValue)
          WITH parentNode, nestedProps
          CALL apoc.create.setProperty(parentNode, nestedProps.property_name,nestedProps.GBDR_value ) YIELD node
          RETURN "done";


          //Step 2.4.6: Transform blank attribute nodes into labeled properties on parent node with value 'NULL_AT_IMPORT'.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH DISTINCT parent_node, m1prop._name as prop_name, collect("NULL_AT_IMPORT") AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH m1prop
          DETACH DELETE m1prop;

          //Step 2.4.7: Remove 'entity' labels from nodes in the the 'System_Model' subgraph.
          MATCH(:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent:entity)
          REMOVE ent:entity;

          //Step 2.4.8: Change label of node named 'database' from 'XmlTag' to 'System_Model'.
          MATCH (database:XmlTag {_name:"database"})
          SET database:System_Model
          REMOVE database:XmlTag;

          //Step 2.4.9: Change label of 'xmlDocument' node to  'importedXmlDocument'.
          MATCH (a:XmlDocument)
          SET a:importedXmlDocument
          REMOVE a:XmlDocument;

          //Step 3.0: Condense Label subgraph into Reference Form (not used in initial GBDR instantiation).

          //Step 3.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 3.2: Create edge between parent and child label nodes.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(child) WHERE child.parentId is not null
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent {id:child.parentId})
          CREATE (child)-[:child_of]->(parent);

          //Step 3.3: Create an edge between label nodes and the schema class to which they point.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(label) WHERE label.schemaClassId is not null
          MATCH(sClass:schemaClass {id:label.schemaClassId})
          CREATE (label)-[:label_for]->(sClass);

          //Step 3.4: (Label subgraph cleanup) Remove 'XmlTag' label and add 'Innoslate_Label' as node label.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*0..]-(lab)
          SET lab:Innoslate_Labels
          REMOVE lab:XmlTag;




//Add Q-093
MATCH (a)-[:IS_CHILD_OF*1..]->(b:System_Model)-[:IS_CHILD_OF]->(c:Model_Package{uniqueProjectId:'1399819159'})
REMOVE a:systemC
SET a:Q093
WITH DISTINCT b
SET b.name='Q-093';





//CREATE EXAMPLE SYSTEM MODEL RQ-095

          //Import Algorithm for Innoslate System Model from Local Drive to Neo4j GBDR.
          //Step 0: Import and Pre-processing of XML file content.
          //Step 0.1: Import XML file from local director.
          call apoc.xml.import("file:///Users/danie/.Neo4jDesktop/neo4jDatabases/database-b2c772db-f121-42a9-92d8-915048491c98/installation-4.3.5/import/RQ-095 High Fidelity UAV Model.xml",{filterLeadingWhitespace:true,delimiter:"X0Y9A8B7"}) yield node
          return "done";

          //Step 0.2: Remove relationships generated by APOC XML Import procedure that aren't used in the GBDR.
          MATCH (a)-[n]->(b) WHERE (a:XmlDocument OR a:XmlCharacters OR a:XmlTag) AND type(n) <> 'IS_CHILD_OF' DELETE n;

          //Step 0.3: Transform uniqueProjectId and children nodes from separate nodes to labeled properties.
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT model_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH model_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(model_node,prop_name,prop_text2) YIELD node
          RETURN node;
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 0.4: Create additional labels for immediate children nodes of root content node (where name is 'innoslate').
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*1..2]-(child_node)
          WITH child_node, collect(child_node._name) AS node_name
          CALL apoc.create.addLabels(child_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 0.5: (Document level subgraph cleanup) Remove 'XmlTag' label and add 'Model_Package' label.
          MATCH(a:XmlTag {_name:"innoslate"})
          SET a:Model_Package
          REMOVE a:XmlTag;

          //Step 1.0: Generate ODL subgraph from 'schema' sub-graph.

          //Step 1.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(child_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT child_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH child_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(child_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'ODL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 1.2: Change node labels from 'XmlTag' to 'SchemaClass' and 'SchemaRelation'.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(end_node:XmlTag)
          WITH end_node, collect(end_node._name) AS node_name
          CALL apoc.create.addLabels(end_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 1.3: Create edges between connected schemaClass nodes using Id references.
          MATCH (schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF]-(rels:xmlTargetRelation)
          MATCH (a:schemaClass) WHERE a.id = rels.sourceId
          OPTIONAL MATCH (b:schemaClass) WHERE b.id = rels.targetId
          OPTIONAL MATCH (c:schemaRelation) WHERE c.id = rels.relationId
          CREATE(a)-[:source_of {GBDR_level:"ODL"}]->(c)
          CREATE(b)-[:target_of {GBDR_level:"ODL"}]->(c)
          DETACH DELETE rels;

          //Step 1.4: ODL subgraph cleanup ('schema' subgraph of XML import graph).

          //Step 1.4.1: Change label of node named 'schema' from 'XmlTag' to 'Ontology'.
          MATCH (schema:XmlTag {_name:"schema"})
          SET schema:Ontology
          REMOVE schema:XmlTag;

          //Step 1.4.2: Change relationship between schemaProperty nodes and schemaClass nodes to 'defined_by'.
          MATCH (a:schemaProperty)-[r:IS_CHILD_OF]->(b) WHERE b:schemaClass OR b:schemaRelation
          CREATE (a)<-[:defined_by {GBDR_level:"ODL"}]-(b)
          WITH r DELETE r;

          //Step 1.4.3: Create subclass relationship between parent and child classes.
          MATCH (child:schemaClass)
          MATCH (parent:schemaClass {id:child.parentId})
          CREATE (child)-[:subclass_of {GBDR_level:"ODL"}]->(parent);

          //Step 1.4.4: Create inverse relationship schemaRelations to reflect inverseRelationId.
          MATCH(r1:schemaRelation)
          MATCH(r2:schemaRelation {id:r1.inverseRelationId})
          CREATE (r1)-[:Inverse_of]->(r2);

          //Step 2.0: Generate SMDL subgraph from 'database' sub-graph of XML import graph.

          //Step 2.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 2.2: Change entity node labels from 'XmlTag' to value of 'name' property of referenced schemaClass node.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent {_name:'entity'})
          MATCH(sClass:schemaClass {id:ent.schemaClassId})
          WITH ent, collect(sClass.name) AS node_name
          CALL apoc.create.addLabels(ent,node_name) YIELD node
          SET ent:entity
          REMOVE ent:XmlTag;

          //Step 2.3: Transform relationships from nodes to edges.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(rels {_name:'relationship'})
          MATCH(target:entity {globalId:rels.targetId})
          MATCH(source:entity {globalId:rels.sourceId})
          MATCH(sRel:schemaRelation {id:rels.schemaRelationId})
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF]-(rels_link:XmlTag {_name:"booleanAttribute"})
          OPTIONAL MATCH (sProp:schemaProperty {id:rels_link.schemaPropertyId})
          WITH DISTINCT rels, rels_link, source, sRel.name as rel_name, target, sProp.name as prop_name, rels_link.booleanValue as prop_value
          CALL apoc.create.relationship(source,rel_name,{GBDR_level:"SMDL"},target) YIELD rel as rel1
          WITH rels, rels_link, rel1, prop_name, prop_value
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF*]-(rels_props)
          DETACH DELETE rels_props, rels
          WITH rel1, rels_link, prop_name, prop_value WHERE prop_name IS NOT NULL
          CALL apoc.create.setRelProperty(rel1,prop_name,prop_value) YIELD rel AS rel2
          DETACH DELETE rels_link;

          //Step 2.4: SMDL subgraph cleanup ('database' subgraph of XML import graph).

          //Step 2.4.1: Change distribution attribute children node labels from 'XmlTag' to 'distribution'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'distribution'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DISTRIBUTION
          SET nestedprops:DISTRIBUTION
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'

          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.2: Change simulation data attribute children node labels from 'XmlTag' to 'SIMDATA'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'simulationData'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:SIMDATA
          SET nestedprops:SIMDATA
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.3: Change diagram metadata node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'metadata'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.4: Change diagram node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'xmlDiagram'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.5: Change complex attribute node labels 'XmlTags' nodes to 'NestedProperty'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag) WHERE m1prop._name IN ["dateAttribute", "doubleAttribute", "durationAttribute", "stringAttribute", "numberAttribute", "qualityAttribute"
          ]
          MATCH (sProp:schemaProperty {id:m1prop.schemaPropertyId})
          SET m1prop:Nested_Property
          SET m1prop.property_name = sProp.name
          REMOVE m1prop:XmlTag;
          MATCH (nestedProps:Nested_Property)-[:IS_CHILD_OF]->(parentNode)
          SET nestedProps.GBDR_value = coalesce(nestedProps.value,nestedProps.doubleValue,nestedProps.booleanValue)
          WITH parentNode, nestedProps
          CALL apoc.create.setProperty(parentNode, nestedProps.property_name,nestedProps.GBDR_value ) YIELD node
          RETURN "done";


          //Step 2.4.6: Transform blank attribute nodes into labeled properties on parent node with value 'NULL_AT_IMPORT'.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH DISTINCT parent_node, m1prop._name as prop_name, collect("NULL_AT_IMPORT") AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH m1prop
          DETACH DELETE m1prop;

          //Step 2.4.7: Remove 'entity' labels from nodes in the the 'System_Model' subgraph.
          MATCH(:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent:entity)
          REMOVE ent:entity;

          //Step 2.4.8: Change label of node named 'database' from 'XmlTag' to 'System_Model'.
          MATCH (database:XmlTag {_name:"database"})
          SET database:System_Model
          REMOVE database:XmlTag;

          //Step 2.4.9: Change label of 'xmlDocument' node to  'importedXmlDocument'.
          MATCH (a:XmlDocument)
          SET a:importedXmlDocument
          REMOVE a:XmlDocument;

          //Step 3.0: Condense Label subgraph into Reference Form (not used in initial GBDR instantiation).

          //Step 3.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 3.2: Create edge between parent and child label nodes.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(child) WHERE child.parentId is not null
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent {id:child.parentId})
          CREATE (child)-[:child_of]->(parent);

          //Step 3.3: Create an edge between label nodes and the schema class to which they point.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(label) WHERE label.schemaClassId is not null
          MATCH(sClass:schemaClass {id:label.schemaClassId})
          CREATE (label)-[:label_for]->(sClass);

          //Step 3.4: (Label subgraph cleanup) Remove 'XmlTag' label and add 'Innoslate_Label' as node label.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*0..]-(lab)
          SET lab:Innoslate_Labels
          REMOVE lab:XmlTag;




//Add Q-095
MATCH (a)-[:IS_CHILD_OF*1..]->(b:System_Model)-[:IS_CHILD_OF]->(c:Model_Package{uniqueProjectId:'-64709397'})
REMOVE a:systemC
SET a:RQ095
WITH DISTINCT b
SET b.name='RQ-095';

//CREATE EXAMPLE SYSTEM MODEL RQ-105

          //Import Algorithm for Innoslate System Model from Local Drive to Neo4j GBDR.
          //Step 0: Import and Pre-processing of XML file content.
          //Step 0.1: Import XML file from local director.
          call apoc.xml.import("file:///Users/danie/.Neo4jDesktop/neo4jDatabases/database-b2c772db-f121-42a9-92d8-915048491c98/installation-4.3.5/import/RQ-105 UAV Model.xml",{filterLeadingWhitespace:true,delimiter:"X0Y9A8B7"}) yield node
          return "done";

          //Step 0.2: Remove relationships generated by APOC XML Import procedure that aren't used in the GBDR.
          MATCH (a)-[n]->(b) WHERE (a:XmlDocument OR a:XmlCharacters OR a:XmlTag) AND type(n) <> 'IS_CHILD_OF' DELETE n;

          //Step 0.3: Transform uniqueProjectId and children nodes from separate nodes to labeled properties.
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT model_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH model_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(model_node,prop_name,prop_text2) YIELD node
          RETURN node;
          MATCH(model_node:XmlTag {_name:"innoslate"})<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 0.4: Create additional labels for immediate children nodes of root content node (where name is 'innoslate').
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*1..2]-(child_node)
          WITH child_node, collect(child_node._name) AS node_name
          CALL apoc.create.addLabels(child_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 0.5: (Document level subgraph cleanup) Remove 'XmlTag' label and add 'Model_Package' label.
          MATCH(a:XmlTag {_name:"innoslate"})
          SET a:Model_Package
          REMOVE a:XmlTag;

          //Step 1.0: Generate ODL subgraph from 'schema' sub-graph.

          //Step 1.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(child_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT child_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH child_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(child_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'ODL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 1.2: Change node labels from 'XmlTag' to 'SchemaClass' and 'SchemaRelation'.
          MATCH(schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF*]-(end_node:XmlTag)
          WITH end_node, collect(end_node._name) AS node_name
          CALL apoc.create.addLabels(end_node,node_name) YIELD node
          REMOVE node:XmlTag
          RETURN node;

          //Step 1.3: Create edges between connected schemaClass nodes using Id references.
          MATCH (schema:XmlTag {_name:"schema"})<-[:IS_CHILD_OF]-(rels:xmlTargetRelation)
          MATCH (a:schemaClass) WHERE a.id = rels.sourceId
          OPTIONAL MATCH (b:schemaClass) WHERE b.id = rels.targetId
          OPTIONAL MATCH (c:schemaRelation) WHERE c.id = rels.relationId
          CREATE(a)-[:source_of {GBDR_level:"ODL"}]->(c)
          CREATE(b)-[:target_of {GBDR_level:"ODL"}]->(c)
          DETACH DELETE rels;

          //Step 1.4: ODL subgraph cleanup ('schema' subgraph of XML import graph).

          //Step 1.4.1: Change label of node named 'schema' from 'XmlTag' to 'Ontology'.
          MATCH (schema:XmlTag {_name:"schema"})
          SET schema:Ontology
          REMOVE schema:XmlTag;

          //Step 1.4.2: Change relationship between schemaProperty nodes and schemaClass nodes to 'defined_by'.
          MATCH (a:schemaProperty)-[r:IS_CHILD_OF]->(b) WHERE b:schemaClass OR b:schemaRelation
          CREATE (a)<-[:defined_by {GBDR_level:"ODL"}]-(b)
          WITH r DELETE r;

          //Step 1.4.3: Create subclass relationship between parent and child classes.
          MATCH (child:schemaClass)
          MATCH (parent:schemaClass {id:child.parentId})
          CREATE (child)-[:subclass_of {GBDR_level:"ODL"}]->(parent);

          //Step 1.4.4: Create inverse relationship schemaRelations to reflect inverseRelationId.
          MATCH(r1:schemaRelation)
          MATCH(r2:schemaRelation {id:r1.inverseRelationId})
          CREATE (r1)-[:Inverse_of]->(r2);

          //Step 2.0: Generate SMDL subgraph from 'database' sub-graph of XML import graph.

          //Step 2.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 2.2: Change entity node labels from 'XmlTag' to value of 'name' property of referenced schemaClass node.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent {_name:'entity'})
          MATCH(sClass:schemaClass {id:ent.schemaClassId})
          WITH ent, collect(sClass.name) AS node_name
          CALL apoc.create.addLabels(ent,node_name) YIELD node
          SET ent:entity
          REMOVE ent:XmlTag;

          //Step 2.3: Transform relationships from nodes to edges.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(rels {_name:'relationship'})
          MATCH(target:entity {globalId:rels.targetId})
          MATCH(source:entity {globalId:rels.sourceId})
          MATCH(sRel:schemaRelation {id:rels.schemaRelationId})
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF]-(rels_link:XmlTag {_name:"booleanAttribute"})
          OPTIONAL MATCH (sProp:schemaProperty {id:rels_link.schemaPropertyId})
          WITH DISTINCT rels, rels_link, source, sRel.name as rel_name, target, sProp.name as prop_name, rels_link.booleanValue as prop_value
          CALL apoc.create.relationship(source,rel_name,{GBDR_level:"SMDL"},target) YIELD rel as rel1
          WITH rels, rels_link, rel1, prop_name, prop_value
          OPTIONAL MATCH (rels)<-[:IS_CHILD_OF*]-(rels_props)
          DETACH DELETE rels_props, rels
          WITH rel1, rels_link, prop_name, prop_value WHERE prop_name IS NOT NULL
          CALL apoc.create.setRelProperty(rel1,prop_name,prop_value) YIELD rel AS rel2
          DETACH DELETE rels_link;

          //Step 2.4: SMDL subgraph cleanup ('database' subgraph of XML import graph).

          //Step 2.4.1: Change distribution attribute children node labels from 'XmlTag' to 'distribution'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'distribution'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DISTRIBUTION
          SET nestedprops:DISTRIBUTION
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'

          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.2: Change simulation data attribute children node labels from 'XmlTag' to 'SIMDATA'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'simulationData'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:SIMDATA
          SET nestedprops:SIMDATA
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.3: Change diagram metadata node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'metadata'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.4: Change diagram node labels from 'XmlTag' to 'DIAGRAMS'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag {_name:'xmlDiagram'})
          OPTIONAL MATCH (m1prop)<-[:IS_CHILD_OF*1..]-(nestedprops:XmlTag)
          SET m1prop:DIAGRAMS
          SET nestedprops:DIAGRAMS
          SET m1prop.GBDR_level='SMDL'
          SET nestedprops.GBDR_level='SMDL'
          REMOVE m1prop:XmlTag
          REMOVE nestedprops:XmlTag;

          //Step 2.4.5: Change complex attribute node labels 'XmlTags' nodes to 'NestedProperty'.
          MATCH (database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(m1prop:XmlTag) WHERE m1prop._name IN ["dateAttribute", "doubleAttribute", "durationAttribute", "stringAttribute", "numberAttribute", "qualityAttribute"
          ]
          MATCH (sProp:schemaProperty {id:m1prop.schemaPropertyId})
          SET m1prop:Nested_Property
          SET m1prop.property_name = sProp.name
          REMOVE m1prop:XmlTag;
          MATCH (nestedProps:Nested_Property)-[:IS_CHILD_OF]->(parentNode)
          SET nestedProps.GBDR_value = coalesce(nestedProps.value,nestedProps.doubleValue,nestedProps.booleanValue)
          WITH parentNode, nestedProps
          CALL apoc.create.setProperty(parentNode, nestedProps.property_name,nestedProps.GBDR_value ) YIELD node
          RETURN "done";


          //Step 2.4.6: Transform blank attribute nodes into labeled properties on parent node with value 'NULL_AT_IMPORT'.
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH DISTINCT parent_node, m1prop._name as prop_name, collect("NULL_AT_IMPORT") AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(database:XmlTag {_name:"database"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(m1prop:XmlTag) WHERE m1prop.schemaPropertyId IS NULL AND keys(m1prop) = ["_name"]
          WITH m1prop
          DETACH DELETE m1prop;

          //Step 2.4.7: Remove 'entity' labels from nodes in the the 'System_Model' subgraph.
          MATCH(:XmlTag {_name:"database"})<-[:IS_CHILD_OF]-(ent:entity)
          REMOVE ent:entity;

          //Step 2.4.8: Change label of node named 'database' from 'XmlTag' to 'System_Model'.
          MATCH (database:XmlTag {_name:"database"})
          SET database:System_Model
          REMOVE database:XmlTag;

          //Step 2.4.9: Change label of 'xmlDocument' node to  'importedXmlDocument'.
          MATCH (a:XmlDocument)
          SET a:importedXmlDocument
          REMOVE a:XmlDocument;

          //Step 3.0: Condense Label subgraph into Reference Form (not used in initial GBDR instantiation).

          //Step 3.1: Transform XmlCharacters nodes from separate nodes to labeled properties.
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH DISTINCT parent_node, property_name._name as prop_name, collect(property_value.text) AS prop_text
          WITH parent_node, prop_name, CASE
                                          WHEN size(prop_text) > 1 THEN prop_text
                                          ELSE head(prop_text)
                                          END AS prop_text2
          CALL apoc.create.setProperty(parent_node,prop_name,prop_text2) YIELD node
          SET node.GBDR_level = 'SMDL'
          RETURN node;
          MATCH(schema:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent_node)<-[:IS_CHILD_OF]-(property_name)<-[:IS_CHILD_OF]-(property_value:XmlCharacters)
          WITH property_name, property_value
          DETACH DELETE property_name, property_value;

          //Step 3.2: Create edge between parent and child label nodes.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(child) WHERE child.parentId is not null
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(parent {id:child.parentId})
          CREATE (child)-[:child_of]->(parent);

          //Step 3.3: Create an edge between label nodes and the schema class to which they point.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*]-(label) WHERE label.schemaClassId is not null
          MATCH(sClass:schemaClass {id:label.schemaClassId})
          CREATE (label)-[:label_for]->(sClass);

          //Step 3.4: (Label subgraph cleanup) Remove 'XmlTag' label and add 'Innoslate_Label' as node label.
          MATCH(:XmlTag {_name:"labels"})<-[:IS_CHILD_OF*0..]-(lab)
          SET lab:Innoslate_Labels
          REMOVE lab:XmlTag;




//Add RQ-105
MATCH (a)-[:IS_CHILD_OF*1..]->(b:System_Model)-[:IS_CHILD_OF]->(c:Model_Package{uniqueProjectId:'-928723320'})
REMOVE a:systemC
SET a:RQ105
WITH DISTINCT b
SET b.name='RQ-105';


//Code below creates syntheticElements that match the name of each node with the name property key
//For application to other node labels, only the first match subquery needs to be changed
MATCH(a:SMDL) AS smdl_nodes
WITH smdl_nodes WHERE 'name' IN keys(smdl_nodes)
//Section below retrieves matching wikidata items based on rdfs:label
//Returned items are added to the GBDR as a syntheticElement node (root synthetic node)
//A relationship between the created between syntheticElement node and SMDL node
WITH "SELECT ?subject ?subjectName ?subjectDescription WHERE { ?subject rdfs:label \"" +
toLower(smdl_nodes.name) + "\"@en . ?subject schema:description ?subjectDescription filter(lang(?subjectDescription) = \"en\"). ?subject rdfs:label ?subjectName filter(lang(?subjectName) = \"en\").}" AS sparql, smdl_nodes
CALL apoc.load.jsonParams(
  "http://query.wikidata.org/sparql?query=" + sparql,
  { Accept: "application/sparql-results+json",failOnError:false},
  null) YIELD value
WITH value, smdl_nodes
CALL apoc.do.when(
  size(value.results.bindings) > 0,
  '
  UNWIND value.results.bindings AS result
  WITH result, smdl_nodes
   MERGE (synEle:syntheticElement {name:result.subjectName.value, globalId:result.subject.value, description:result.subjectDescription.value})
   MERGE (smdl_nodes)-[:SYNTHETIC_DEFINED_BY {Synthetic:"TRUE"}]->(synEle)
   RETURN smdl_nodes',
   'SET smdl_nodes.SYNTH_DATA_IMPORT = true RETURN smdl_nodes',
  {value: value, smdl_nodes: smdl_nodes})
YIELD value AS result
WITH smdl_nodes
//Query wikidata for the value of "said to be the same as" (P460) for root synthetic node
MATCH (smdl_nodes)-[:SYNTHETIC_DEFINED_BY]->(synthEle)
WITH DISTINCT synthEle as synthSet
WITH "SELECT ?sameAsId ?sameAsName ?sameAsDescription WHERE { <" +
synthSet.globalId + "> wdt:P460 ?sameAsId . ?sameAsId schema:description ?sameAsDescription filter(lang(?sameAsDescription) = \"en\").  ?sameAsId rdfs:label ?sameAsName filter(lang(?sameAsName) = \"en\").}" AS sparql, synthSet
CALL apoc.load.jsonParams(
  "http://query.wikidata.org/sparql?query=" + sparql,
  { Accept: "application/sparql-results+json",failOnError:false},
  null)
YIELD value
CALL apoc.do.when(
  size(value.results.bindings) > 0,
  '
  UNWIND value.results.bindings AS result
  WITH result, synthSet
  MERGE (synEle:syntheticElement {name:result.sameAsName.value, globalId:result.sameAsId.value, description:result.sameAsDescription.value})
  MERGE (synthSet)-[:SYNTHETIC_SAME_AS {Synthetic:"TRUE"}]-(synEle)
  RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
  {value: value, synthSet : synthSet})
YIELD value AS result

//Query wikidata for the value of "synonym" (P5973) for root synthetic node
WITH synthSet
WITH "SELECT ?synonymOfId ?synonymOfName ?synonymOfDescription WHERE { <" +
synthSet.globalId + "> wdt:P5973 ?synonymOfId . ?synonymOfId schema:description ?synonymOfDescription filter(lang(?synonymOfDescription) = \"en\").  ?synonymOfId rdfs:label ?synonymOfName filter(lang(?synonymOfName) = \"en\").}" AS sparql, synthSet
CALL apoc.load.jsonParams(
  "http://query.wikidata.org/sparql?query=" + sparql,
  { Accept: "application/sparql-results+json",failOnError:false},
  null)
YIELD value
CALL apoc.do.when(
  size(value.results.bindings) > 0,
  '
  UNWIND value.results.bindings AS result
  WITH result, synthSet WHERE result is not null
  MERGE (synEle:syntheticElement {name:result.synonymOfName.value, globalId:result.synonymOfId.value, description:result.synonymOfDescription.value})
  MERGE (synthSet)-[:SYNTHETIC_SYNONYM_OF {Synthetic:"TRUE"}]-(synEle)
  RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
  {value: value, synthSet : synthSet})
YIELD value AS result

//Query wikidata for the value of "instance of" (P31) for root synthetic node
WITH synthSet
WITH "SELECT ?instanceOfId ?instanceOfName ?instanceOfDescription WHERE { <" +
synthSet.globalId + "> wdt:P31 ?instanceOfId . ?instanceOfId schema:description ?instanceOfDescription filter(lang(?instanceOfDescription) = \"en\").  ?instanceOfId rdfs:label ?instanceOfName filter(lang(?instanceOfName) = \"en\").}" AS sparql, synthSet
CALL apoc.load.jsonParams(
  "http://query.wikidata.org/sparql?query=" + sparql,
  { Accept: "application/sparql-results+json",failOnError:false},
  null)
YIELD value
CALL apoc.do.when(
  size(value.results.bindings) > 0,
  '
  UNWIND value.results.bindings AS result
  WITH result, synthSet WHERE result is not null
  MERGE (synEle:syntheticElement {name:result.instanceOfName.value, globalId:result.instanceOfId.value, description:result.instanceOfDescription.value})
  MERGE (synthSet)-[:SYNTHETIC_INSTANCE_OF {Synthetic:"TRUE"}]-(synEle)
  RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
  {value: value, synthSet : synthSet})
YIELD value AS result

//Query wikidata for the value of "exact match" (P2888) for root synthetic node
WITH synthSet
WITH "SELECT ?exactMatchId ?exactMatchName ?exactMatchDescription WHERE { <" +
synthSet.globalId + "> wdt:P31 ?exactMatchId . ?exactMatchId schema:description ?exactMatchDescription filter(lang(?exactMatchDescription) = \"en\").  ?exactMatchId rdfs:label ?exactMatchName filter(lang(?exactMatchName) = \"en\").}" AS sparql, synthSet
CALL apoc.load.jsonParams(
  "http://query.wikidata.org/sparql?query=" + sparql,
  {Accept: "application/sparql-results+json",failOnError:false},
  null)
YIELD value
CALL apoc.do.when(
  size(value.results.bindings) > 0,
  '
  UNWIND value.results.bindings AS result
  WITH result, synthSet WHERE result is not null
  MERGE (synEle:syntheticElement {name:result.exactMatchName.value, globalId:result.exactMatchId.value, description:result.exactMatchDescription.value})
  MERGE (synthSet)-[:SYNTHETIC_EXACT_MATCH {Synthetic:"TRUE"}]-(synEle)
  RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
  {value: value, synthSet : synthSet})
YIELD value AS result

//Query wikidata for the superclass of all existing syntheticElements connected
//to the root synthetic node
MATCH (smdl_nodes)-[:SYNTHETIC_DEFINED_BY ]->()-[*0..1]->(synthEle)
WITH DISTINCT synthEle as synthSet
WITH "SELECT ?superClassId ?superClassName ?superClassDescription WHERE { <" +
synthSet.globalId + "> wdt:P279 ?superClassId . ?superClassId schema:description ?superClassDescription filter(lang(?superClassDescription) = \"en\").  ?superClassId rdfs:label ?superClassName filter(lang(?superClassName) = \"en\").}" AS sparql, synthSet
CALL apoc.load.jsonParams(
  "http://query.wikidata.org/sparql?query=" + sparql,
  { Accept: "application/sparql-results+json", failOnError:false},
  null)
YIELD value

CALL apoc.do.when(
  size(value.results.bindings) > 0,
  '
  UNWIND value.results.bindings AS result
  WITH result, synthSet WHERE result is not null
  MERGE (synEle:syntheticElement {name:result.superClassName.value, globalId:result.superClassId.value, description:result.superClassDescription.value})
  MERGE (synthSet)-[:SYNTHETIC_SUBCLASS_OF {Synthetic:"TRUE"}]-(synEle)
  RETURN synthSet','SET synthSet.SYNTH_DATA_IMPORT = true RETURN synthSet',
  {value: value, synthSet : synthSet})
YIELD value AS result
RETURN "done";

//Identify Potentially Equivalent Nodes
MATCH p=(smA:System_Model)<-[:IS_CHILD_OF*1..]-(a)-[*0..5{Synthetic:'TRUE'}]-(b)-[:IS_CHILD_OF*1..]->(smB:System_Model)
WHERE smA<>smB
AND NOT a:syntheticElement
AND NOT b:syntheticElement
AND id(a)>id(b) //Avoids two pairs of (a,b) and (b,a)
WITH DISTINCT a,b
MERGE (a)-[:POTENTIAL_MATCH]-(b);
